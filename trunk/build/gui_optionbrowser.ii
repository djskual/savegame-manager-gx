# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.cpp"
# 1 "d:\\Projects\\SaveGameManager\\savegame-manager-gx\\trunk\\build//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.cpp"
# 17 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.cpp"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.h" 1
# 17 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.h"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_element.h" 1
# 20 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_element.h"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 1



# 1 "d:/devkitPro/libogc/include/gccore.h" 1
# 39 "d:/devkitPro/libogc/include/gccore.h"
# 1 "d:/devkitPro/libogc/include/ogc/dsp.h" 1
# 39 "d:/devkitPro/libogc/include/ogc/dsp.h"
# 1 "d:/devkitPro/libogc/include/gctypes.h" 1
# 9 "d:/devkitPro/libogc/include/gctypes.h"
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdbool.h" 1 3 4
# 10 "d:/devkitPro/libogc/include/gctypes.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdint.h" 1 3 4


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 1 3 4
# 13 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
extern "C" {
# 41 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed char int8_t ;
typedef unsigned char uint8_t ;




typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;




typedef signed short int16_t;
typedef unsigned short uint16_t;
# 67 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;
# 79 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed int int32_t;
typedef unsigned int uint32_t;
# 97 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;
# 119 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed long long int64_t;
typedef unsigned long long uint64_t;
# 129 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;
# 159 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef signed int int_fast8_t;
  typedef unsigned int uint_fast8_t;




  typedef signed int int_fast16_t;
  typedef unsigned int uint_fast16_t;




  typedef signed int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 213 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef int_least64_t int_fast64_t;
  typedef uint_least64_t uint_fast64_t;







  typedef long long int intmax_t;
# 231 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef long long unsigned int uintmax_t;
# 243 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed int intptr_t;
typedef unsigned int uintptr_t;
# 490 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
}
# 4 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdint.h" 2 3 4
# 11 "d:/devkitPro/libogc/include/gctypes.h" 2


   extern "C" {



typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;
typedef int64_t s64;

typedef volatile u8 vu8;
typedef volatile u16 vu16;
typedef volatile u32 vu32;
typedef volatile u64 vu64;

typedef volatile s8 vs8;
typedef volatile s16 vs16;
typedef volatile s32 vs32;
typedef volatile s64 vs64;


typedef s16 sfp16;
typedef s32 sfp32;
typedef u16 ufp16;
typedef u32 ufp32;

typedef float f32;
typedef double f64;

typedef volatile float vf32;
typedef volatile double vf64;



typedef unsigned int BOOL;
# 88 "d:/devkitPro/libogc/include/gctypes.h"
struct __argv {
 int argvMagic;
 char *commandLine;
 int length;
 int argc;
 char **argv;
 char **endARGV;
};


extern struct __argv *__system_argv;





   }
# 40 "d:/devkitPro/libogc/include/ogc/dsp.h" 2
# 72 "d:/devkitPro/libogc/include/ogc/dsp.h"
   extern "C" {







typedef struct _dsp_task dsptask_t;






typedef void (*DSPTaskCallback)(dsptask_t *task);





typedef void (*DSPCallback)(void);
# 115 "d:/devkitPro/libogc/include/ogc/dsp.h"
struct _dsp_task {
 vu32 state;
 vu32 prio;
 vu32 flags;

 void *iram_maddr;
 u32 iram_len;
 u32 iram_addr;

 void *dram_maddr;
 u32 dram_len;
 u32 dram_addr;

 u16 init_vec;
 u16 resume_vec;

 DSPTaskCallback init_cb;
 DSPTaskCallback res_cb;
 DSPTaskCallback done_cb;
 DSPTaskCallback req_cb;

 struct _dsp_task *next;
 struct _dsp_task *prev;
};







void DSP_Init();







u32 DSP_CheckMailTo();







u32 DSP_CheckMailFrom();







u32 DSP_ReadMailFrom();







void DSP_AssertInt();
# 187 "d:/devkitPro/libogc/include/ogc/dsp.h"
void DSP_SendMailTo(u32 mail);







u32 DSP_ReadCPUtoDSP();
# 204 "d:/devkitPro/libogc/include/ogc/dsp.h"
dsptask_t* DSP_AddTask(dsptask_t *task);

dsptask_t* DSP_AssertTask(dsptask_t *task);

void DSP_CancelTask(dsptask_t *task);

void DSP_Reset();

void DSP_Halt();

void DSP_Unhalt();







DSPCallback DSP_RegisterCallback(DSPCallback usr_cb);


   }
# 40 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/aram.h" 1
# 71 "d:/devkitPro/libogc/include/ogc/aram.h"
   extern "C" {
# 81 "d:/devkitPro/libogc/include/ogc/aram.h"
typedef void (*ARCallback)(void);
# 94 "d:/devkitPro/libogc/include/ogc/aram.h"
ARCallback AR_RegisterCallback(ARCallback callback);
# 103 "d:/devkitPro/libogc/include/ogc/aram.h"
u32 AR_GetDMAStatus();
# 147 "d:/devkitPro/libogc/include/ogc/aram.h"
u32 AR_Init(u32 *stack_idx_array,u32 num_entries);
# 167 "d:/devkitPro/libogc/include/ogc/aram.h"
void AR_StartDMA(u32 dir,u32 memaddr,u32 aramaddr,u32 len);
# 180 "d:/devkitPro/libogc/include/ogc/aram.h"
u32 AR_Alloc(u32 len);
# 191 "d:/devkitPro/libogc/include/ogc/aram.h"
u32 AR_Free(u32 *len);
# 202 "d:/devkitPro/libogc/include/ogc/aram.h"
void AR_Clear(u32 flag);
# 212 "d:/devkitPro/libogc/include/ogc/aram.h"
BOOL AR_CheckInit();
# 223 "d:/devkitPro/libogc/include/ogc/aram.h"
void AR_Reset();
# 232 "d:/devkitPro/libogc/include/ogc/aram.h"
u32 AR_GetSize();
# 241 "d:/devkitPro/libogc/include/ogc/aram.h"
u32 AR_GetBaseAddress();
# 250 "d:/devkitPro/libogc/include/ogc/aram.h"
u32 AR_GetInternalSize();
# 269 "d:/devkitPro/libogc/include/ogc/aram.h"
   }
# 41 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/arqueue.h" 1
# 36 "d:/devkitPro/libogc/include/ogc/arqueue.h"
# 1 "d:/devkitPro/libogc/include/ogc/lwp_queue.h" 1
# 13 "d:/devkitPro/libogc/include/ogc/lwp_queue.h"
extern "C" {


typedef struct _lwpnode {
 struct _lwpnode *next;
 struct _lwpnode *prev;
} lwp_node;

typedef struct _lwpqueue {
 lwp_node *first;
 lwp_node *perm_null;
 lwp_node *last;
} lwp_queue;

void __lwp_queue_initialize(lwp_queue *,void *,u32,u32);
lwp_node* __lwp_queue_get(lwp_queue *);
void __lwp_queue_append(lwp_queue *,lwp_node *);
void __lwp_queue_extract(lwp_node *);
void __lwp_queue_insert(lwp_node *,lwp_node *);






 }
# 37 "d:/devkitPro/libogc/include/ogc/arqueue.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/aram.h" 1
# 38 "d:/devkitPro/libogc/include/ogc/arqueue.h" 2
# 48 "d:/devkitPro/libogc/include/ogc/arqueue.h"
   extern "C" {


enum {
 ARQ_TASK_READY = 0,
 ARQ_TASK_RUNNING,
 ARQ_TASK_FINISHED
};

typedef struct _arq_request ARQRequest;
typedef void (*ARQCallback)(ARQRequest *);

struct _arq_request {
 lwp_node node;
 u32 owner,dir,prio,state;
 u32 aram_addr,mram_addr,len;
 ARQCallback callback;
};

void ARQ_Init();
void ARQ_Reset();
# 86 "d:/devkitPro/libogc/include/ogc/arqueue.h"
void ARQ_PostRequest(ARQRequest *req,u32 owner,u32 dir,u32 prio,u32 aram_addr,u32 mram_addr,u32 len);
# 104 "d:/devkitPro/libogc/include/ogc/arqueue.h"
void ARQ_PostRequestAsync(ARQRequest *req,u32 owner,u32 dir,u32 prio,u32 aram_addr,u32 mram_addr,u32 len,ARQCallback cb);
void ARQ_RemoveRequest(ARQRequest *req);
void ARQ_SetChunkSize(u32 size);
u32 ARQ_GetChunkSize();
void ARQ_FlushQueue();
u32 ARQ_RemoveOwnerRequest(u32 owner);


   }
# 42 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/arqmgr.h" 1
# 47 "d:/devkitPro/libogc/include/ogc/arqmgr.h"
   extern "C" {
# 56 "d:/devkitPro/libogc/include/ogc/arqmgr.h"
typedef void (*ARQMCallback)(s32 result);
# 68 "d:/devkitPro/libogc/include/ogc/arqmgr.h"
void ARQM_Init(u32 arambase,s32 len);
# 80 "d:/devkitPro/libogc/include/ogc/arqmgr.h"
u32 ARQM_PushData(void *buffer,s32 len);
# 89 "d:/devkitPro/libogc/include/ogc/arqmgr.h"
u32 ARQM_GetZeroBuffer();
# 98 "d:/devkitPro/libogc/include/ogc/arqmgr.h"
u32 ARQM_GetStackPointer();
# 107 "d:/devkitPro/libogc/include/ogc/arqmgr.h"
u32 ARQM_GetFreeSize();


   }
# 43 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/audio.h" 1
# 70 "d:/devkitPro/libogc/include/ogc/audio.h"
   extern "C" {
# 79 "d:/devkitPro/libogc/include/ogc/audio.h"
typedef void (*AIDCallback)(void);
# 88 "d:/devkitPro/libogc/include/ogc/audio.h"
typedef void (*AISCallback)(u32 smp_cnt);
# 99 "d:/devkitPro/libogc/include/ogc/audio.h"
AISCallback AUDIO_RegisterStreamCallback(AISCallback callback);
# 110 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_Init(u8 *stack);
# 121 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_SetStreamVolLeft(u8 vol);
# 130 "d:/devkitPro/libogc/include/ogc/audio.h"
u8 AUDIO_GetStreamVolLeft();
# 141 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_SetStreamVolRight(u8 vol);
# 150 "d:/devkitPro/libogc/include/ogc/audio.h"
u8 AUDIO_GetStreamVolRight();
# 161 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_SetStreamSampleRate(u32 rate);
# 170 "d:/devkitPro/libogc/include/ogc/audio.h"
u32 AUDIO_GetStreamSampleRate();
# 184 "d:/devkitPro/libogc/include/ogc/audio.h"
AIDCallback AUDIO_RegisterDMACallback(AIDCallback callback);
# 196 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_InitDMA(u32 startaddr,u32 len);
# 205 "d:/devkitPro/libogc/include/ogc/audio.h"
u16 AUDIO_GetDMAEnableFlag();
# 217 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_StartDMA();
# 226 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_StopDMA();
# 235 "d:/devkitPro/libogc/include/ogc/audio.h"
u32 AUDIO_GetDMABytesLeft();
# 244 "d:/devkitPro/libogc/include/ogc/audio.h"
u32 AUDIO_GetDMALength();
# 253 "d:/devkitPro/libogc/include/ogc/audio.h"
u32 AUDIO_GetDMAStartAddr();
# 264 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_SetStreamTrigger(u32 cnt);
# 273 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_ResetStreamSampleCnt();
# 284 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_SetDSPSampleRate(u8 rate);
# 293 "d:/devkitPro/libogc/include/ogc/audio.h"
u32 AUDIO_GetDSPSampleRate();
# 304 "d:/devkitPro/libogc/include/ogc/audio.h"
void AUDIO_SetStreamPlayState(u32 state);
# 313 "d:/devkitPro/libogc/include/ogc/audio.h"
u32 AUDIO_GetStreamPlayState();


   }
# 44 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/cache.h" 1
# 47 "d:/devkitPro/libogc/include/ogc/cache.h"
   extern "C" {
# 57 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCEnable();
# 66 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCDisable();
# 78 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCFreeze();
# 90 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCUnfreeze();
# 102 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCFlashInvalidate();
# 116 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCInvalidateRange(void *startaddress,u32 len);
# 131 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCFlushRange(void *startaddress,u32 len);
# 144 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCStoreRange(void *startaddress,u32 len);
# 159 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCFlushRangeNoSync(void *startaddress,u32 len);
# 173 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCStoreRangeNoSync(void *startaddress,u32 len);
# 185 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCZeroRange(void *startaddress,u32 len);
# 197 "d:/devkitPro/libogc/include/ogc/cache.h"
void DCTouchRange(void *startaddress,u32 len);
# 208 "d:/devkitPro/libogc/include/ogc/cache.h"
void ICSync();
# 220 "d:/devkitPro/libogc/include/ogc/cache.h"
void ICFlashInvalidate();
# 229 "d:/devkitPro/libogc/include/ogc/cache.h"
void ICEnable();
# 238 "d:/devkitPro/libogc/include/ogc/cache.h"
void ICDisable();
# 250 "d:/devkitPro/libogc/include/ogc/cache.h"
void ICFreeze();
# 262 "d:/devkitPro/libogc/include/ogc/cache.h"
void ICUnfreeze();
# 275 "d:/devkitPro/libogc/include/ogc/cache.h"
void ICBlockInvalidate(void *startaddress);
# 289 "d:/devkitPro/libogc/include/ogc/cache.h"
void ICInvalidateRange(void *startaddress,u32 len);
# 304 "d:/devkitPro/libogc/include/ogc/cache.h"
void L2Enhance();


void LCEnable();
void LCDisable();
void LCLoadBlocks(void *,void *,u32);
void LCStoreBlocks(void *,void *,u32);
u32 LCLoadData(void *,void *,u32);
u32 LCStoreData(void *,void *,u32);
u32 LCQueueLength();
u32 LCQueueWait(u32);
void LCFlushQueue();
void LCAlloc(void *,u32);
void LCAllocNoInvalidate(void *,u32);
void LCAllocOneTag(BOOL,void *);
void LCAllocTags(BOOL,void *,u32);



   }
# 45 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/card.h" 1
# 117 "d:/devkitPro/libogc/include/ogc/card.h"
   extern "C" {
# 129 "d:/devkitPro/libogc/include/ogc/card.h"
typedef struct _card_file {
 s32 chn;
 s32 filenum;
 s32 offset;
 s32 len;
 u16 iblock;
} card_file;
# 148 "d:/devkitPro/libogc/include/ogc/card.h"
typedef struct _card_dir {
      s32 chn;
      u32 fileno;
   u32 filelen;
   u8 permissions;
      u8 filename[32];
      u8 gamecode[4];
      u8 company[2];
      bool showall;
} card_dir;
# 176 "d:/devkitPro/libogc/include/ogc/card.h"
typedef struct _card_stat {
 u8 filename[32];
 u32 len;
 u32 time;
 u8 gamecode[4];
 u8 company[2];
 u8 banner_fmt;
 u32 icon_addr;
 u16 icon_fmt;
 u16 iconfmt[8];
 u16 icon_speed;
 u16 iconspeed[8];
 u32 comment_addr;
 u32 offset_banner;
 u32 offset_banner_tlut;
 u32 offset_icon[8];
 u32 offset_icon_tlut[8];
 u32 offset_data;
} card_stat;
# 210 "d:/devkitPro/libogc/include/ogc/card.h"
typedef void (*cardcallback)(s32 chan,s32 result);
# 220 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_Init(const char *gamecode,const char *company);
# 229 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_Probe(s32 chn);
# 240 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_ProbeEx(s32 chn,s32 *mem_size,s32 *sect_size);
# 251 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_Mount(s32 chn,void *workarea,cardcallback detach_cb);
# 263 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_MountAsync(s32 chn,void *workarea,cardcallback detach_cb,cardcallback attach_cb);
# 272 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_Unmount(s32 chn);
# 284 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_Read(card_file *file,void *buffer,u32 len,u32 offset);
# 297 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_ReadAsync(card_file *file,void *buffer,u32 len,u32 offset,cardcallback callback);
# 308 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_Open(s32 chn,const char *filename,card_file *file);
# 319 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_OpenEntry(s32 chn,card_dir *entry,card_file *file);
# 328 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_Close(card_file *file);
# 340 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_Create(s32 chn,const char *filename,u32 size,card_file *file);
# 353 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_CreateAsync(s32 chn,const char *filename,u32 size,card_file *file,cardcallback callback);
# 364 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_CreateEntry(s32 chn,card_dir *direntry,card_file *file);
# 376 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_CreateEntryAsync(s32 chn,card_dir *direntry,card_file *file,cardcallback callback);
# 386 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_Delete(s32 chn,const char *filename);
# 397 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_DeleteAsync(s32 chn,const char *filename,cardcallback callback);
# 407 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_DeleteEntry(s32 chn,card_dir *dir_entry);
# 418 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_DeleteEntryAsync(s32 chn,card_dir *dir_entry,cardcallback callback);
# 430 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_Write(card_file *file,void *buffer,u32 len,u32 offset);
# 443 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_WriteAsync(card_file *file,void *buffer,u32 len,u32 offset,cardcallback callback);
# 452 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_GetErrorCode(s32 chn);
# 463 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_FindFirst(s32 chn, card_dir *dir, bool showall);
# 472 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_FindNext(card_dir *dir);
# 484 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_GetDirectory(s32 chn, card_dir *dir_entries, s32 *count, bool showall);
# 494 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_GetSectorSize(s32 chn,u32 *sector_size);
# 504 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_GetBlockCount(s32 chn,u32 *block_count);
# 515 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_GetStatus(s32 chn,s32 fileno,card_stat *stats);
# 526 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_SetStatus(s32 chn,s32 fileno,card_stat *stats);
# 538 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_SetStatusAsync(s32 chn,s32 fileno,card_stat *stats,cardcallback callback);
# 549 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_GetAttributes(s32 chn,s32 fileno,u8 *attr);
# 560 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_SetAttributes(s32 chn,s32 fileno,u8 attr);
# 572 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_SetAttributesAsync(s32 chn,s32 fileno,u8 attr,cardcallback callback);




s32 CARD_Format(s32 chn);



s32 CARD_FormatAsync(s32 chn,cardcallback callback);
# 590 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_SetCompany(const char *company);
# 599 "d:/devkitPro/libogc/include/ogc/card.h"
s32 CARD_SetGamecode(const char *gamecode);


   }
# 46 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/cast.h" 1
# 25 "d:/devkitPro/libogc/include/ogc/cast.h"
extern "C" {







static inline void CAST_Init()
{
 __asm__ __volatile__ (
  "li		3,0x0004\n		 oris	3,3,0x0004\n		 mtspr	914,3\n		 li		3,0x0005\n		 oris	3,3,0x0005\n		 mtspr	915,3\n		 li		3,0x0006\n		 oris	3,3,0x0006\n		 mtspr	916,3\n		 li		3,0x0007\n		 oris	3,3,0x0007\n		 mtspr	917,3\n"
# 48 "d:/devkitPro/libogc/include/ogc/cast.h"
   : : : "r3"
 );
}

static inline void CAST_SetGQR2(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(914), "b"(val));
}

static inline void CAST_SetGQR3(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(915), "b"(val));
}

static inline void CAST_SetGQR4(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(916), "b"(val));
}

static inline void CAST_SetGQR5(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(917), "b"(val));
}

static inline void CAST_SetGQR6(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(918), "b"(val));
}

static inline void CAST_SetGQR7(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(919), "b"(val));
}
# 95 "d:/devkitPro/libogc/include/ogc/cast.h"
static inline f32 __castu8f32(register u8 *in)
{
 register f32 rval;
 __asm__ __volatile__ (
  "psq_l	%[rval],0(%[in]),1,2" : [rval]"=f"(rval) : [in]"r"(in)
 );
 return rval;
}

static inline f32 __castu16f32(register u16 *in)
{
 register f32 rval;
 __asm__ __volatile__ (
  "psq_l	%[rval],0(%[in]),1,3" : [rval]"=f"(rval) : [in]"r"(in)
 );
 return rval;
}

static inline f32 __casts8f32(register s8 *in)
{
 register f32 rval;
 __asm__ __volatile__ (
  "psq_l	%[rval],0(%[in]),1,4" : [rval]"=f"(rval) : [in]"r"(in)
 );
 return rval;
}

static inline f32 __casts16f32(register s16 *in)
{
 register f32 rval;
 __asm__ __volatile__ (
  "psq_l	%[rval],0(%[in]),1,5" : [rval]"=f"(rval) : [in]"r"(in)
 );
 return rval;
}

static inline void castu8f32(register u8 *in,register volatile f32 *out)
{
 *out = __castu8f32(in);
}

static inline void castu16f32(register u16 *in,register volatile f32 *out)
{
 *out = __castu16f32(in);
}

static inline void casts8f32(register s8 *in,register volatile f32 *out)
{
 *out = __casts8f32(in);
}

static inline void casts16f32(register s16 *in,register volatile f32 *out)
{
 *out = __casts16f32(in);
}







static inline u8 __castf32u8(register f32 in)
{
 f32 a;
 register u8 rval;
 register f32 *ptr = &a;

 __asm__ __volatile__ (
  "psq_st	%[in],0(%[ptr]),1,2\n"
  "lbz	%[out],0(%[ptr])\n"
  : [out]"=r"(rval), [ptr]"+r"(ptr) : [in]"f"(in)
 );
 return rval;
}

static inline u16 __castf32u16(register f32 in)
{
 f32 a;
 register u16 rval;
 register f32 *ptr = &a;

 __asm__ __volatile__ (
  "psq_st	%[in],0(%[ptr]),1,3\n"
  "lhz	%[out],0(%[ptr])\n"
  : [out]"=r"(rval), [ptr]"+r"(ptr) : [in]"f"(in)
 );
 return rval;
}

static inline s8 __castf32s8(register f32 in)
{
 f32 a;
 register s8 rval;
 register f32 *ptr = &a;

 __asm__ __volatile__ (
  "psq_st	%[in],0(%[ptr]),1,4\n"
  "lbz	%[out],0(%[ptr])\n"
  : [out]"=r"(rval), [ptr]"+r"(ptr) : [in]"f"(in)
 );
 return rval;
}

static inline s16 __castf32s16(register f32 in)
{
 f32 a;
 register s16 rval;
 register f32 *ptr = &a;

 __asm__ __volatile__ (
  "psq_st	%[in],0(%[ptr]),1,5\n"
  "lha	%[out],0(%[ptr])\n"
  : [out]"=r"(rval), [ptr]"+r"(ptr) : [in]"f"(in)
 );
 return rval;
}

static inline void castf32u8(register f32 *in,register vu8 *out)
{
 *out = __castf32u8(*in);
}

static inline void castf32u16(register f32 *in,register vu16 *out)
{
 *out = __castf32u16(*in);
}

static inline void castf32s8(register f32 *in,register vs8 *out)
{
 *out = __castf32s8(*in);
}

static inline void castf32s16(register f32 *in,register vs16 *out)
{
 *out = __castf32s16(*in);
}




}
# 47 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/color.h" 1
# 48 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/consol.h" 1
# 10 "d:/devkitPro/libogc/include/ogc/consol.h"
# 1 "d:/devkitPro/libogc/include/ogc/gx_struct.h" 1
# 42 "d:/devkitPro/libogc/include/ogc/gx_struct.h"
   extern "C" {
# 58 "d:/devkitPro/libogc/include/ogc/gx_struct.h"
typedef struct _gx_rmodeobj {
 u32 viTVMode;
 u16 fbWidth;
 u16 efbHeight;
 u16 xfbHeight;
 u16 viXOrigin;
 u16 viYOrigin;
 u16 viWidth;
 u16 viHeight;
 u32 xfbMode;
 u8 field_rendering;
 u8 aa;
 u8 sample_pattern[12][2];
 u8 vfilter[7];
} GXRModeObj;


   }
# 11 "d:/devkitPro/libogc/include/ogc/consol.h" 2






 extern "C" {
# 31 "d:/devkitPro/libogc/include/ogc/consol.h"
void CON_Init(void *framebuffer,int xstart,int ystart,int xres,int yres,int stride);
# 44 "d:/devkitPro/libogc/include/ogc/consol.h"
s32 CON_InitEx(GXRModeObj *rmode, s32 conXOrigin,s32 conYOrigin,s32 conWidth,s32 conHeight);
# 54 "d:/devkitPro/libogc/include/ogc/consol.h"
void CON_GetMetrics(int *cols, int *rows);
# 64 "d:/devkitPro/libogc/include/ogc/consol.h"
void CON_GetPosition(int *cols, int *rows);
# 75 "d:/devkitPro/libogc/include/ogc/consol.h"
void CON_EnableGecko(int channel,int safe);


 }
# 49 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/dvd.h" 1
# 42 "d:/devkitPro/libogc/include/ogc/dvd.h"
# 1 "d:/devkitPro/libogc/include/ogc/disc_io.h" 1
# 46 "d:/devkitPro/libogc/include/ogc/disc_io.h"
typedef uint32_t sec_t;

typedef bool (* FN_MEDIUM_STARTUP)(void) ;
typedef bool (* FN_MEDIUM_ISINSERTED)(void) ;
typedef bool (* FN_MEDIUM_READSECTORS)(sec_t sector, sec_t numSectors, void* buffer) ;
typedef bool (* FN_MEDIUM_WRITESECTORS)(sec_t sector, sec_t numSectors, const void* buffer) ;
typedef bool (* FN_MEDIUM_CLEARSTATUS)(void) ;
typedef bool (* FN_MEDIUM_SHUTDOWN)(void) ;

struct DISC_INTERFACE_STRUCT {
 unsigned long ioType ;
 unsigned long features ;
 FN_MEDIUM_STARTUP startup ;
 FN_MEDIUM_ISINSERTED isInserted ;
 FN_MEDIUM_READSECTORS readSectors ;
 FN_MEDIUM_WRITESECTORS writeSectors ;
 FN_MEDIUM_CLEARSTATUS clearStatus ;
 FN_MEDIUM_SHUTDOWN shutdown ;
} ;

typedef struct DISC_INTERFACE_STRUCT DISC_INTERFACE ;
# 43 "d:/devkitPro/libogc/include/ogc/dvd.h" 2
# 103 "d:/devkitPro/libogc/include/ogc/dvd.h"
   extern "C" {







typedef struct _dvddiskid dvddiskid;
# 128 "d:/devkitPro/libogc/include/ogc/dvd.h"
struct _dvddiskid {
 s8 gamename[4];
 s8 company[2];
 u8 disknum;
 u8 gamever;
 u8 streaming;
 u8 streambufsize;
 u8 pad[22];
};





typedef struct _dvdcmdblk dvdcmdblk;






typedef void (*dvdcbcallback)(s32 result,dvdcmdblk *block);







struct _dvdcmdblk {
 lwp_node node;
 u32 cmd;
 s32 state;
 s64 offset;
 u32 len;
 void *buf;
 u32 currtxsize;
 u32 txdsize;
 dvddiskid *id;
 dvdcbcallback cb;
 void *usrdata;
};






typedef struct _dvddrvinfo dvddrvinfo;
# 190 "d:/devkitPro/libogc/include/ogc/dvd.h"
struct _dvddrvinfo {
 u16 rev_level;
 u16 dev_code;
 u32 rel_date;
 u8 pad[24];
};






typedef struct _dvdfileinfo dvdfileinfo;
# 212 "d:/devkitPro/libogc/include/ogc/dvd.h"
typedef void (*dvdcallback)(s32 result,dvdfileinfo *info);







struct _dvdfileinfo {
 dvdcmdblk block;
 u32 addr;
 u32 len;
 dvdcallback cb;
};
# 236 "d:/devkitPro/libogc/include/ogc/dvd.h"
void DVD_Init();
void DVD_Pause();
# 248 "d:/devkitPro/libogc/include/ogc/dvd.h"
void DVD_Reset(u32 reset_mode);
# 259 "d:/devkitPro/libogc/include/ogc/dvd.h"
s32 DVD_Mount();
s32 DVD_GetDriveStatus();
# 283 "d:/devkitPro/libogc/include/ogc/dvd.h"
s32 DVD_MountAsync(dvdcmdblk *block,dvdcbcallback cb);
# 297 "d:/devkitPro/libogc/include/ogc/dvd.h"
s32 DVD_ControlDrive(dvdcmdblk *block,u32 cmd);
# 310 "d:/devkitPro/libogc/include/ogc/dvd.h"
s32 DVD_ControlDriveAsync(dvdcmdblk *block,u32 cmd,dvdcbcallback cb);
# 324 "d:/devkitPro/libogc/include/ogc/dvd.h"
s32 DVD_SetGCMOffset(dvdcmdblk *block,s64 offset);
# 339 "d:/devkitPro/libogc/include/ogc/dvd.h"
s32 DVD_SetGCMOffsetAsync(dvdcmdblk *block,s64 offset,dvdcbcallback cb);

s32 DVD_GetCmdBlockStatus(dvdcmdblk *block);
s32 DVD_SpinUpDrive(dvdcmdblk *block);
s32 DVD_SpinUpDriveAsync(dvdcmdblk *block,dvdcbcallback cb);
s32 DVD_Inquiry(dvdcmdblk *block,dvddrvinfo *info);
s32 DVD_InquiryAsync(dvdcmdblk *block,dvddrvinfo *info,dvdcbcallback cb);
s32 DVD_ReadPrio(dvdcmdblk *block,void *buf,u32 len,s64 offset,s32 prio);
s32 DVD_ReadAbsAsyncPrio(dvdcmdblk *block,void *buf,u32 len,s64 offset,dvdcbcallback cb,s32 prio);
s32 DVD_ReadAbsAsyncForBS(dvdcmdblk *block,void *buf,u32 len,s64 offset,dvdcbcallback cb);
s32 DVD_SeekPrio(dvdcmdblk *block,s64 offset,s32 prio);
s32 DVD_SeekAbsAsyncPrio(dvdcmdblk *block,s64 offset,dvdcbcallback cb,s32 prio);
s32 DVD_CancelAllAsync(dvdcbcallback cb);
s32 DVD_StopStreamAtEndAsync(dvdcmdblk *block,dvdcbcallback cb);
s32 DVD_StopStreamAtEnd(dvdcmdblk *block);
s32 DVD_ReadDiskID(dvdcmdblk *block,dvddiskid *id,dvdcbcallback cb);
u32 DVD_SetAutoInvalidation(u32 auto_inv);
dvddiskid* DVD_GetCurrentDiskID();
dvddrvinfo* DVD_GetDriveInfo();





extern const DISC_INTERFACE __io_gcdvd;


   }
# 50 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/exi.h" 1
# 138 "d:/devkitPro/libogc/include/ogc/exi.h"
   extern "C" {







typedef s32 (*EXICallback)(s32 chn,s32 dev);
# 155 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_ProbeEx(s32 nChn);
# 164 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_Probe(s32 nChn);
# 175 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_Lock(s32 nChn,s32 nDev,EXICallback unlockCB);
# 184 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_Unlock(s32 nChn);
# 195 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_Select(s32 nChn,s32 nDev,s32 nFrq);
# 206 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_SelectSD(s32 nChn,s32 nDev,s32 nFrq);
# 215 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_Deselect(s32 nChn);
# 224 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_Sync(s32 nChn);
# 237 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_Imm(s32 nChn,void *pData,u32 nLen,u32 nMode,EXICallback tc_cb);
# 249 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_ImmEx(s32 nChn,void *pData,u32 nLen,u32 nMode);
# 262 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_Dma(s32 nChn,void *pData,u32 nLen,u32 nMode,EXICallback tc_cb);
# 271 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_GetState(s32 nChn);
# 282 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_GetID(s32 nChn,s32 nDev,u32 *nId);
# 292 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_Attach(s32 nChn,EXICallback ext_cb);
# 301 "d:/devkitPro/libogc/include/ogc/exi.h"
s32 EXI_Detach(s32 nChn);







void EXI_ProbeReset();
# 319 "d:/devkitPro/libogc/include/ogc/exi.h"
EXICallback EXI_RegisterEXICallback(s32 nChn,EXICallback exi_cb);


   }
# 51 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/gu.h" 1
# 80 "d:/devkitPro/libogc/include/ogc/gu.h"
   extern "C" {
# 94 "d:/devkitPro/libogc/include/ogc/gu.h"
typedef struct _vecf {
 f32 x,y,z;
} guVector;
# 107 "d:/devkitPro/libogc/include/ogc/gu.h"
typedef struct _qrtn {
 f32 x,y,z,w;
} guQuaternion;





typedef f32 Mtx[3][4];
typedef f32 (*MtxP)[4];







typedef f32 ROMtx[4][3];
typedef f32 (*ROMtxP)[3];




typedef f32 Mtx33[3][3];
typedef f32 (*Mtx33P)[3];





typedef f32 Mtx44[4][4];
typedef f32 (*Mtx44P)[4];
# 162 "d:/devkitPro/libogc/include/ogc/gu.h"
void guFrustum(Mtx44 mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 f);
# 187 "d:/devkitPro/libogc/include/ogc/gu.h"
void guPerspective(Mtx44 mt,f32 fovy,f32 aspect,f32 n,f32 f);
# 211 "d:/devkitPro/libogc/include/ogc/gu.h"
void guOrtho(Mtx44 mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 f);
# 244 "d:/devkitPro/libogc/include/ogc/gu.h"
void guLightPerspective(Mtx mt,f32 fovY,f32 aspect,f32 scaleS,f32 scaleT,f32 transS,f32 transT);
# 273 "d:/devkitPro/libogc/include/ogc/gu.h"
void guLightOrtho(Mtx mt,f32 t,f32 b,f32 l,f32 r,f32 scaleS,f32 scaleT,f32 transS,f32 transT);
# 303 "d:/devkitPro/libogc/include/ogc/gu.h"
void guLightFrustum(Mtx mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 scaleS,f32 scaleT,f32 transS,f32 transT);
# 325 "d:/devkitPro/libogc/include/ogc/gu.h"
void guLookAt(Mtx mt,guVector *camPos,guVector *camUp,guVector *target);
# 346 "d:/devkitPro/libogc/include/ogc/gu.h"
void guVecHalfAngle(guVector *a,guVector *b,guVector *half);

void c_guVecAdd(guVector *a,guVector *b,guVector *ab);
void c_guVecSub(guVector *a,guVector *b,guVector *ab);
void c_guVecScale(guVector *src,guVector *dst,f32 scale);
void c_guVecNormalize(guVector *v);
void c_guVecMultiply(Mtx mt,guVector *src,guVector *dst);
void c_guVecCross(guVector *a,guVector *b,guVector *axb);
void c_guVecMultiplySR(Mtx mt,guVector *src,guVector *dst);
f32 c_guVecDotProduct(guVector *a,guVector *b);


void ps_guVecAdd(register guVector *a,register guVector *b,register guVector *ab);
void ps_guVecSub(register guVector *a,register guVector *b,register guVector *ab);
void ps_guVecScale(register guVector *src,register guVector *dst,f32 scale);
void ps_guVecNormalize(register guVector *v);
void ps_guVecCross(register guVector *a,register guVector *b,register guVector *axb);
void ps_guVecMultiply(register Mtx mt,register guVector *src,register guVector *dst);
void ps_guVecMultiplySR(register Mtx mt,register guVector *src,register guVector *dst);
f32 ps_guVecDotProduct(register guVector *a,register guVector *b);


void c_guQuatAdd(guQuaternion *a,guQuaternion *b,guQuaternion *ab);
void c_guQuatSub(guQuaternion *a,guQuaternion *b,guQuaternion *ab);
void c_guQuatMultiply(guQuaternion *a,guQuaternion *b,guQuaternion *ab);
void c_guQuatNormalize(guQuaternion *a,guQuaternion *d);
void c_guQuatInverse(guQuaternion *a,guQuaternion *d);
void c_guQuatMtx(guQuaternion *a,Mtx m);


void ps_guQuatAdd(register guQuaternion *a,register guQuaternion *b,register guQuaternion *ab);
void ps_guQuatSub(register guQuaternion *a,register guQuaternion *b,register guQuaternion *ab);
void ps_guQuatMultiply(register guQuaternion *a,register guQuaternion *b,register guQuaternion *ab);
void ps_guQuatNormalize(register guQuaternion *a,register guQuaternion *d);
void ps_guQuatInverse(register guQuaternion *a,register guQuaternion *d);


void c_guMtxIdentity(Mtx mt);
void c_guMtxCopy(Mtx src,Mtx dst);
void c_guMtxConcat(Mtx a,Mtx b,Mtx ab);
void c_guMtxScale(Mtx mt,f32 xS,f32 yS,f32 zS);
void c_guMtxScaleApply(Mtx src,Mtx dst,f32 xS,f32 yS,f32 zS);
void c_guMtxApplyScale(Mtx src,Mtx dst,f32 xS,f32 yS,f32 zS);
void c_guMtxTrans(Mtx mt,f32 xT,f32 yT,f32 zT);
void c_guMtxTransApply(Mtx src,Mtx dst,f32 xT,f32 yT,f32 zT);
void c_guMtxApplyTrans(Mtx src,Mtx dst,f32 xT,f32 yT,f32 zT);
u32 c_guMtxInverse(Mtx src,Mtx inv);
u32 c_guMtxInvXpose(Mtx src,Mtx xPose);
void c_guMtxTranspose(Mtx src,Mtx xPose);
void c_guMtxRotRad(Mtx mt,const char axis,f32 rad);
void c_guMtxRotTrig(Mtx mt,const char axis,f32 sinA,f32 cosA);
void c_guMtxRotAxisRad(Mtx mt,guVector *axis,f32 rad);
void c_guMtxReflect(Mtx m,guVector *p,guVector *n);
void c_guMtxQuat(Mtx m,guQuaternion *a);


void ps_guMtxIdentity(register Mtx mt);
void ps_guMtxCopy(register Mtx src,register Mtx dst);
void ps_guMtxConcat(register Mtx a,register Mtx b,register Mtx ab);
void ps_guMtxTranspose(register Mtx src,register Mtx xPose);
u32 ps_guMtxInverse(register Mtx src,register Mtx inv);
u32 ps_guMtxInvXpose(register Mtx src,register Mtx xPose);
void ps_guMtxScale(register Mtx mt,register f32 xS,register f32 yS,register f32 zS);
void ps_guMtxScaleApply(register Mtx src,register Mtx dst,register f32 xS,register f32 yS,register f32 zS);
void ps_guMtxApplyScale(register Mtx src,register Mtx dst,register f32 xS,register f32 yS,register f32 zS);
void ps_guMtxTrans(register Mtx mt,register f32 xT,register f32 yT,register f32 zT);
void ps_guMtxTransApply(register Mtx src,register Mtx dst,register f32 xT,register f32 yT,register f32 zT);
void ps_guMtxApplyTrans(register Mtx src,register Mtx dst,register f32 xT,register f32 yT,register f32 zT);
void ps_guMtxRotRad(register Mtx mt,register const char axis,register f32 rad);
void ps_guMtxRotTrig(register Mtx mt,register const char axis,register f32 sinA,register f32 cosA);
void ps_guMtxRotAxisRad(register Mtx mt,register guVector *axis,register f32 tmp0);
void ps_guMtxReflect(register Mtx m,register guVector *p,register guVector *n);
# 496 "d:/devkitPro/libogc/include/ogc/gu.h"
   }
# 52 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/gx.h" 1
# 11 "d:/devkitPro/libogc/include/ogc/gx.h"
# 1 "d:/devkitPro/libogc/include/ogc/lwp.h" 1
# 55 "d:/devkitPro/libogc/include/ogc/lwp.h"
extern "C" {






typedef u32 lwp_t;





typedef u32 lwpq_t;
# 81 "d:/devkitPro/libogc/include/ogc/lwp.h"
s32 LWP_CreateThread(lwp_t *thethread,void* (*entry)(void *),void *arg,void *stackbase,u32 stack_size,u8 prio);
# 90 "d:/devkitPro/libogc/include/ogc/lwp.h"
s32 LWP_SuspendThread(lwp_t thethread);
# 99 "d:/devkitPro/libogc/include/ogc/lwp.h"
s32 LWP_ResumeThread(lwp_t thethread);
# 108 "d:/devkitPro/libogc/include/ogc/lwp.h"
BOOL LWP_ThreadIsSuspended(lwp_t thethread);







lwp_t LWP_GetSelf();
# 126 "d:/devkitPro/libogc/include/ogc/lwp.h"
void LWP_SetThreadPriority(lwp_t thethread,u32 prio);







void LWP_YieldThread();
# 143 "d:/devkitPro/libogc/include/ogc/lwp.h"
void LWP_Reschedule(u32 prio);
# 153 "d:/devkitPro/libogc/include/ogc/lwp.h"
s32 LWP_JoinThread(lwp_t thethread,void **value_ptr);
# 162 "d:/devkitPro/libogc/include/ogc/lwp.h"
s32 LWP_InitQueue(lwpq_t *thequeue);
# 171 "d:/devkitPro/libogc/include/ogc/lwp.h"
void LWP_CloseQueue(lwpq_t thequeue);
# 180 "d:/devkitPro/libogc/include/ogc/lwp.h"
s32 LWP_ThreadSleep(lwpq_t thequeue);
# 189 "d:/devkitPro/libogc/include/ogc/lwp.h"
void LWP_ThreadSignal(lwpq_t thequeue);
# 198 "d:/devkitPro/libogc/include/ogc/lwp.h"
void LWP_ThreadBroadcast(lwpq_t thequeue);


 }
# 12 "d:/devkitPro/libogc/include/ogc/gx.h" 2

# 1 "d:/devkitPro/libogc/include/ogc/gu.h" 1
# 14 "d:/devkitPro/libogc/include/ogc/gx.h" 2
# 1165 "d:/devkitPro/libogc/include/ogc/gx.h"
   extern "C" {


typedef union _wgpipe
{
 vu8 U8;
 vs8 S8;
 vu16 U16;
 vs16 S16;
 vu32 U32;
 vs32 S32;
 vf32 F32;
} WGPipe;




typedef struct _gx_color {
  u8 r;
  u8 g;
  u8 b;
 u8 a;
} GXColor;




typedef struct _gx_colors10 {
  s16 r;
  s16 g;
  s16 b;
 s16 a;
} GXColorS10;
# 1209 "d:/devkitPro/libogc/include/ogc/gx.h"
typedef struct _gx_texobj {
 u32 val[8];
} GXTexObj;
# 1223 "d:/devkitPro/libogc/include/ogc/gx.h"
typedef struct _gx_tlutobj {
 u32 val[3];
} GXTlutObj;
# 1237 "d:/devkitPro/libogc/include/ogc/gx.h"
typedef struct _gx_texreg {
 u32 val[4];
} GXTexRegion;
# 1251 "d:/devkitPro/libogc/include/ogc/gx.h"
typedef struct _gx_tlutreg {
 u32 val[4];
} GXTlutRegion;
# 1265 "d:/devkitPro/libogc/include/ogc/gx.h"
typedef struct _gx_litobj {
 u32 val[16];
} GXLightObj;

typedef struct _vtx {
 f32 x,y,z;
 u16 s,t;
 u32 rgba;
} Vtx;







typedef struct {
 u8 attr;
 u8 type;
} GXVtxDesc;







typedef struct {
 u32 vtxattr;
 u32 comptype;
 u32 compsize;
 u32 frac;
} GXVtxAttrFmt;
# 1309 "d:/devkitPro/libogc/include/ogc/gx.h"
typedef struct {
 u8 pad[128];
} GXFifoObj;

typedef struct {
 u8 dummy[4];
} GXTexReg;




typedef struct {
 u16 r[10];
} GXFogAdjTbl;




typedef void (*GXBreakPtCallback)(void);




typedef void (*GXDrawDoneCallback)(void);





typedef void (*GXDrawSyncCallback)(u16 token);





typedef GXTexRegion* (*GXTexRegionCallback)(GXTexObj *obj,u8 mapid);





typedef GXTlutRegion* (*GXTlutRegionCallback)(u32 tlut_name);

extern WGPipe* const wgPipe;
# 1377 "d:/devkitPro/libogc/include/ogc/gx.h"
GXFifoObj* GX_Init(void *base,u32 size);
# 1407 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitFifoBase(GXFifoObj *fifo,void *base,u32 size);
# 1431 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitFifoLimits(GXFifoObj *fifo,u32 hiwatermark,u32 lowatermark);
# 1445 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitFifoPtrs(GXFifoObj *fifo,void *rd_ptr,void *wt_ptr);
# 1459 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_GetFifoPtrs(GXFifoObj *fifo,void **rd_ptr,void **wt_ptr);
# 1472 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetCPUFifo(GXFifoObj *fifo);
# 1495 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetGPFifo(GXFifoObj *fifo);
# 1505 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_GetCPUFifo(GXFifoObj *fifo);
# 1515 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_GetGPFifo(GXFifoObj *fifo);
# 1525 "d:/devkitPro/libogc/include/ogc/gx.h"
void* GX_GetFifoBase(GXFifoObj *fifo);
# 1538 "d:/devkitPro/libogc/include/ogc/gx.h"
u32 GX_GetFifoCount(GXFifoObj *fifo);
# 1548 "d:/devkitPro/libogc/include/ogc/gx.h"
u32 GX_GetFifoSize(GXFifoObj *fifo);
# 1564 "d:/devkitPro/libogc/include/ogc/gx.h"
u8 GX_GetFifoWrap(GXFifoObj *fifo);
# 1578 "d:/devkitPro/libogc/include/ogc/gx.h"
GXDrawDoneCallback GX_SetDrawDoneCallback(GXDrawDoneCallback cb);
# 1590 "d:/devkitPro/libogc/include/ogc/gx.h"
GXBreakPtCallback GX_SetBreakPtCallback(GXBreakPtCallback cb);
# 1604 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_AbortFrame();
# 1614 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_Flush();
# 1625 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetMisc(u32 token,u32 value);
# 1641 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetDrawDone();
# 1656 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_WaitDrawDone();







u16 GX_GetDrawSync();
# 1678 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetDrawSync(u16 token);
# 1692 "d:/devkitPro/libogc/include/ogc/gx.h"
GXDrawSyncCallback GX_SetDrawSyncCallback(GXDrawSyncCallback cb);
# 1704 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_DisableBreakPt();
# 1729 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_EnableBreakPt(void *break_pt);
# 1739 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_DrawDone();
# 1754 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_TexModeSync();
# 1770 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InvVtxCache();
# 1780 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_ClearVtxDesc();
# 1793 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadProjectionMtx(Mtx44 mt,u8 type);
# 1815 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetViewport(f32 xOrig,f32 yOrig,f32 wd,f32 ht,f32 nearZ,f32 farZ);
# 1837 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetViewportJitter(f32 xOrig,f32 yOrig,f32 wd,f32 ht,f32 nearZ,f32 farZ,u32 field);
# 1872 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetChanCtrl(s32 channel,u8 enable,u8 ambsrc,u8 matsrc,u8 litmask,u8 diff_fn,u8 attn_fn);
# 1885 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetChanAmbColor(s32 channel,GXColor color);
# 1898 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetChanMatColor(s32 channel,GXColor color);
# 1928 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetArray(u32 attr,void *ptr,u8 stride);
# 1954 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetVtxAttrFmt(u8 vtxfmt,u32 vtxattr,u32 comptype,u32 compsize,u32 frac);
# 1969 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetVtxAttrFmtv(u8 vtxfmt,GXVtxAttrFmt *attr_list);
# 1984 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetVtxDesc(u8 attr,u8 type);
# 1998 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetVtxDescv(GXVtxDesc *attr_list);
# 2012 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_GetVtxDescv(GXVtxDesc *attr_list);
# 2037 "d:/devkitPro/libogc/include/ogc/gx.h"
u32 GX_EndDispList();
# 2054 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_Begin(u8 primitve,u8 vtxfmt,u16 vtxcnt);
# 2088 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_BeginDispList(void *list,u32 size);
# 2109 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_CallDispList(void *list,u32 nbytes);







static inline void GX_End()
{
}

static inline void GX_Position3f32(f32 x,f32 y,f32 z)
{
 wgPipe->F32 = x;
 wgPipe->F32 = y;
 wgPipe->F32 = z;
}

static inline void GX_Position3u16(u16 x,u16 y,u16 z)
{
 wgPipe->U16 = x;
 wgPipe->U16 = y;
 wgPipe->U16 = z;
}

static inline void GX_Position3s16(s16 x,s16 y,s16 z)
{
 wgPipe->S16 = x;
 wgPipe->S16 = y;
 wgPipe->S16 = z;
}

static inline void GX_Position3u8(u8 x,u8 y,u8 z)
{
 wgPipe->U8 = x;
 wgPipe->U8 = y;
 wgPipe->U8 = z;
}

static inline void GX_Position3s8(s8 x,s8 y,s8 z)
{
 wgPipe->S8 = x;
 wgPipe->S8 = y;
 wgPipe->S8 = z;
}

static inline void GX_Position2f32(f32 x,f32 y)
{
 wgPipe->F32 = x;
 wgPipe->F32 = y;
}

static inline void GX_Position2u16(u16 x,u16 y)
{
 wgPipe->U16 = x;
 wgPipe->U16 = y;
}

static inline void GX_Position2s16(s16 x,s16 y)
{
 wgPipe->S16 = x;
 wgPipe->S16 = y;
}

static inline void GX_Position2u8(u8 x,u8 y)
{
 wgPipe->U8 = x;
 wgPipe->U8 = y;
}

static inline void GX_Position2s8(s8 x,s8 y)
{
 wgPipe->S8 = x;
 wgPipe->S8 = y;
}

static inline void GX_Position1x8(u8 index)
{
 wgPipe->U8 = index;
}

static inline void GX_Position1x16(u16 index)
{
 wgPipe->U16 = index;
}

static inline void GX_Normal3f32(f32 nx,f32 ny,f32 nz)
{
 wgPipe->F32 = nx;
 wgPipe->F32 = ny;
 wgPipe->F32 = nz;
}

static inline void GX_Normal3s16(s16 nx,s16 ny,s16 nz)
{
 wgPipe->S16 = nx;
 wgPipe->S16 = ny;
 wgPipe->S16 = nz;
}

static inline void GX_Normal3s8(s8 nx,s8 ny,s8 nz)
{
 wgPipe->S8 = nx;
 wgPipe->S8 = ny;
 wgPipe->S8 = nz;
}

static inline void GX_Normal1x8(u8 index)
{
 wgPipe->U8 = index;
}

static inline void GX_Normal1x16(u16 index)
{
 wgPipe->U16 = index;
}

static inline void GX_Color4u8(u8 r,u8 g,u8 b,u8 a)
{
 wgPipe->U8 = r;
 wgPipe->U8 = g;
 wgPipe->U8 = b;
 wgPipe->U8 = a;
}

static inline void GX_Color3u8(u8 r,u8 g,u8 b)
{
 wgPipe->U8 = r;
 wgPipe->U8 = g;
 wgPipe->U8 = b;
}

static inline void GX_Color3f32(f32 r, f32 g, f32 b)
{
 wgPipe->U8 = (u8)(r * 255.0);
 wgPipe->U8 = (u8)(g * 255.0);
 wgPipe->U8 = (u8)(b * 255.0);
}

static inline void GX_Color1u32(u32 clr)
{
 wgPipe->U32 = clr;
}

static inline void GX_Color1u16(u16 clr)
{
 wgPipe->U16 = clr;
}

static inline void GX_Color1x8(u8 index)
{
 wgPipe->U8 = index;
}

static inline void GX_Color1x16(u16 index)
{
 wgPipe->U16 = index;
}

static inline void GX_TexCoord2f32(f32 s,f32 t)
{
 wgPipe->F32 = s;
 wgPipe->F32 = t;
}

static inline void GX_TexCoord2u16(u16 s,u16 t)
{
 wgPipe->U16 = s;
 wgPipe->U16 = t;
}

static inline void GX_TexCoord2s16(s16 s,s16 t)
{
 wgPipe->S16 = s;
 wgPipe->S16 = t;
}

static inline void GX_TexCoord2u8(u8 s,u8 t)
{
 wgPipe->U8 = s;
 wgPipe->U8 = t;
}

static inline void GX_TexCoord2s8(s8 s,s8 t)
{
 wgPipe->S8 = s;
 wgPipe->S8 = t;
}

static inline void GX_TexCoord1f32(f32 s)
{
 wgPipe->F32 = s;
}

static inline void GX_TexCoord1u16(u16 s)
{
 wgPipe->U16 = s;
}

static inline void GX_TexCoord1s16(s16 s)
{
 wgPipe->S16 = s;
}

static inline void GX_TexCoord1u8(u8 s)
{
 wgPipe->U8 = s;
}

static inline void GX_TexCoord1s8(s8 s)
{
 wgPipe->S8 = s;
}

static inline void GX_TexCoord1x8(u8 index)
{
 wgPipe->U8 = index;
}

static inline void GX_TexCoord1x16(u16 index)
{
 wgPipe->U16 = index;
}

static inline void GX_MatrixIndex1x8(u8 index)
{
 wgPipe->U8 = index;
}
# 2358 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_AdjustForOverscan(GXRModeObj *rmin,GXRModeObj *rmout,u16 hor,u16 ver);
# 2381 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadPosMtxImm(Mtx mt,u32 pnidx);
# 2404 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadPosMtxIdx(u16 mtxidx,u32 pnidx);
# 2427 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadNrmMtxImm(Mtx mt,u32 pnidx);
# 2451 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadNrmMtxIdx3x3(u16 mtxidx,u32 pnidx);
# 2477 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadTexMtxImm(Mtx mt,u32 texidx,u8 type);
# 2502 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadTexMtxIdx(u16 mtxidx,u32 texidx,u8 type);
# 2516 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetCurrentMtx(u32 mtx);
# 2533 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevOp(u8 tevstage,u8 mode);
# 2549 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevColor(u8 tev_regid,GXColor color);
# 2565 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevColorS10(u8 tev_regid,GXColorS10 color);
# 2584 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevColorIn(u8 tevstage,u8 a,u8 b,u8 c,u8 d);
# 2602 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevAlphaIn(u8 tevstage,u8 a,u8 b,u8 c,u8 d);
# 2626 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevColorOp(u8 tevstage,u8 tevop,u8 tevbias,u8 tevscale,u8 clamp,u8 tevregid);
# 2650 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevAlphaOp(u8 tevstage,u8 tevop,u8 tevbias,u8 tevscale,u8 clamp,u8 tevregid);
# 2666 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetNumTexGens(u32 nr);
# 2700 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTexCoordGen(u16 texcoord,u32 tgen_typ,u32 tgen_src,u32 mtxsrc);
# 2731 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTexCoordGen2(u16 texcoord,u32 tgen_typ,u32 tgen_src,u32 mtxsrc,u32 normalize,u32 postmtx);
# 2762 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetZTexture(u8 op,u8 fmt,u32 bias);
# 2784 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetZMode(u8 enable,u8 func,u8 update_enable);
# 2797 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetZCompLoc(u8 before_tex);
# 2811 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetLineWidth(u8 width,u8 fmt);
# 2825 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetPointSize(u8 width,u8 fmt);
# 2856 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetBlendMode(u8 type,u8 src_fact,u8 dst_fact,u8 op);
# 2870 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetCullMode(u8 mode);
# 2888 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetCoPlanar(u8 enable);
# 2906 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_EnableTexOffsets(u8 coord,u8 line_enable,u8 point_enable);
# 2920 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetClipMode(u8 mode);
# 2942 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetScissor(u32 xOrigin,u32 yOrigin,u32 wd,u32 ht);
# 2968 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetScissorBoxOffset(s32 xoffset,s32 yoffset);
# 2985 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetNumChans(u8 num);
# 3025 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevOrder(u8 tevstage,u8 texcoord,u32 texmap,u8 color);
# 3044 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetNumTevStages(u8 num);
# 3080 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetAlphaCompare(u8 comp0,u8 ref0,u8 aop,u8 comp1,u8 ref1);
# 3093 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevKColor(u8 sel, GXColor col);
# 3107 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevKColorSel(u8 tevstage,u8 sel);
# 3121 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevKAlphaSel(u8 tevstage,u8 sel);
# 3139 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevKColorS10(u8 sel, GXColorS10 col);
# 3155 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevSwapMode(u8 tevstage,u8 ras_sel,u8 tex_sel);
# 3172 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevSwapModeTable(u8 swapid,u8 r,u8 g,u8 b,u8 a);
# 3191 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevIndirect(u8 tevstage,u8 indtexid,u8 format,u8 bias,u8 mtxid,u8 wrap_s,u8 wrap_t,u8 addprev,u8 utclod,u8 a);
# 3201 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevDirect(u8 tevstage);
# 3213 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetNumIndStages(u8 nstages);
# 3225 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetIndTexOrder(u8 indtexstage,u8 texcoord,u8 texmap);
# 3239 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetIndTexCoordScale(u8 indtexid,u8 scale_s,u8 scale_t);
# 3262 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetFog(u8 type,f32 startz,f32 endz,f32 nearz,f32 farz,GXColor col);
# 3283 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetFogRangeAdj(u8 enable,u16 center,GXFogAdjTbl *table);
# 3293 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetFogColor(GXColor color);
# 3310 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitFogAdjTable(GXFogAdjTbl *table,u16 width,f32 projmtx[4][4]);
# 3330 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetIndTexMatrix(u8 indtexmtx,f32 offset_mtx[2][3],s8 scale_exp);
# 3351 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevIndBumpST(u8 tevstage,u8 indstage,u8 mtx_sel);
# 3369 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevIndBumpXYZ(u8 tevstage,u8 indstage,u8 mtx_sel);
# 3394 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevIndTile(u8 tevstage,u8 indtexid,u16 tilesize_x,u16 tilesize_y,u16 tilespacing_x,u16 tilespacing_y,u8 indtexfmt,u8 indtexmtx,u8 bias_sel,u8 alpha_sel);
# 3406 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTevIndRepeat(u8 tevstage);
# 3418 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetColorUpdate(u8 enable);
# 3433 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetAlphaUpdate(u8 enable);
# 3465 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetPixelFmt(u8 pix_fmt,u8 z_fmt);
# 3482 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetDither(u8 dither);
# 3497 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetDstAlpha(u8 enable,u8 a);
# 3513 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetFieldMask(u8 even_mask,u8 odd_mask);
# 3536 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetFieldMode(u8 field_mode,u8 half_aspect_ratio);
# 3548 "d:/devkitPro/libogc/include/ogc/gx.h"
f32 GX_GetYScaleFactor(u16 efbHeight,u16 xfbHeight);
# 3561 "d:/devkitPro/libogc/include/ogc/gx.h"
u32 GX_SetDispCopyYScale(f32 yscale);
# 3574 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetDispCopySrc(u16 left,u16 top,u16 wd,u16 ht);
# 3588 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetDispCopyDst(u16 wd,u16 ht);
# 3598 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetCopyClamp(u8 clamp);
# 3608 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetDispCopyGamma(u8 gamma);
# 3629 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetCopyFilter(u8 aa,u8 sample_pattern[12][2],u8 vf,u8 vfilter[7]);
# 3645 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetDispCopyFrame2Field(u8 mode);
# 3658 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetCopyClear(GXColor color,u32 zvalue);
# 3676 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_CopyDisp(void *dest,u8 clear);
# 3692 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTexCopySrc(u16 left,u16 top,u16 wd,u16 ht);
# 3718 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTexCopyDst(u16 wd,u16 ht,u32 fmt,u8 mipmap);
# 3732 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_CopyTex(void *dest,u8 clear);
# 3746 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PixModeSync();
# 3756 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_ClearBoundingBox();
# 3777 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PokeAlphaMode(u8 func,u8 threshold);
# 3789 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PokeAlphaUpdate(u8 update_enable);
# 3799 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PokeColorUpdate(u8 update_enable);
# 3813 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PokeDither(u8 dither);
# 3841 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PokeBlendMode(u8 type,u8 src_fact,u8 dst_fact,u8 op);
# 3857 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PokeAlphaRead(u8 mode);
# 3871 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PokeDstAlpha(u8 enable,u8 a);
# 3888 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PokeARGB(u16 x,u16 y,GXColor color);
# 3902 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PeekARGB(u16 x,u16 y,GXColor *color);
# 3920 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PokeZ(u16 x,u16 y,u32 z);
# 3937 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PeekZ(u16 x,u16 y,u32 *z);
# 3961 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PokeZMode(u8 comp_enable,u8 func,u8 update_enable);
# 3973 "d:/devkitPro/libogc/include/ogc/gx.h"
u32 GX_GetTexObjFmt(GXTexObj *obj);
# 3985 "d:/devkitPro/libogc/include/ogc/gx.h"
u32 GX_GetTexObjMipMap(GXTexObj *obj);
# 3997 "d:/devkitPro/libogc/include/ogc/gx.h"
void* GX_GetTexObjUserData(GXTexObj *obj);
# 4009 "d:/devkitPro/libogc/include/ogc/gx.h"
void* GX_GetTexObjData(GXTexObj *obj);
# 4021 "d:/devkitPro/libogc/include/ogc/gx.h"
u8 GX_GetTexObjWrapS(GXTexObj* obj);
# 4033 "d:/devkitPro/libogc/include/ogc/gx.h"
u8 GX_GetTexObjWrapT(GXTexObj* obj);
# 4045 "d:/devkitPro/libogc/include/ogc/gx.h"
u16 GX_GetTexObjHeight(GXTexObj* obj);
# 4057 "d:/devkitPro/libogc/include/ogc/gx.h"
u16 GX_GetTexObjWidth(GXTexObj* obj);
# 4072 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_GetTexObjAll(GXTexObj* obj, void** image_ptr, u16* width, u16* height, u8* format, u8* wrap_s, u8* wrap_t, u8* mipmap);
# 4092 "d:/devkitPro/libogc/include/ogc/gx.h"
u32 GX_GetTexBufferSize(u16 wd,u16 ht,u32 fmt,u8 mipmap,u8 maxlod);
# 4104 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InvalidateTexAll();
# 4123 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InvalidateTexRegion(GXTexRegion *region);
# 4151 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexCacheRegion(GXTexRegion *region,u8 is32bmipmap,u32 tmem_even,u8 size_even,u32 tmem_odd,u8 size_odd);
# 4176 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexPreloadRegion(GXTexRegion *region,u32 tmem_even,u32 size_even,u32 tmem_odd,u32 size_odd);
# 4202 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObj(GXTexObj *obj,void *img_ptr,u16 wd,u16 ht,u8 fmt,u8 wrap_s,u8 wrap_t,u8 mipmap);
# 4235 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjCI(GXTexObj *obj,void *img_ptr,u16 wd,u16 ht,u8 fmt,u8 wrap_s,u8 wrap_t,u8 mipmap,u32 tlut_name);
# 4246 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjTlut(GXTexObj *obj,u32 tlut_name);
# 4260 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjData(GXTexObj *obj,void *img_ptr);
# 4272 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjWrapMode(GXTexObj *obj,u8 wrap_s,u8 wrap_t);
# 4284 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjFilterMode(GXTexObj *obj,u8 minfilt,u8 magfilt);
# 4293 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjMinLOD(GXTexObj *obj,f32 minlod);
# 4302 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjMaxLOD(GXTexObj *obj,f32 maxlod);
# 4315 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjLODBias(GXTexObj *obj,f32 lodbias);
# 4328 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjBiasClamp(GXTexObj *obj,u8 biasclamp);
# 4341 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjEdgeLOD(GXTexObj *obj,u8 edgelod);
# 4359 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjMaxAniso(GXTexObj *obj,u8 maxaniso);
# 4370 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjUserData(GXTexObj *obj,void *userdata);
# 4389 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadTexObj(GXTexObj *obj,u8 mapid);
# 4409 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadTlut(GXTlutObj *obj,u32 tlut_name);
# 4432 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadTexObjPreloaded(GXTexObj *obj,GXTexRegion *region,u8 mapid);
# 4450 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_PreloadEntireTexture(GXTexObj *obj,GXTexRegion *region);
# 4466 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTlutObj(GXTlutObj *obj,void *lut,u8 fmt,u16 entries);
# 4481 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTlutRegion(GXTlutRegion *region,u32 tmem_addr,u8 tlut_sz);
# 4514 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitTexObjLOD(GXTexObj *obj,u8 minfilt,u8 magfilt,f32 minlod,f32 maxlod,f32 lodbias,u8 biasclamp,u8 edgelod,u8 maxaniso);
# 4535 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTexCoordScaleManually(u8 texcoord,u8 enable,u16 ss,u16 ts);
# 4556 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetTexCoordBias(u8 texcoord,u8 s_enable,u8 t_enable);
# 4570 "d:/devkitPro/libogc/include/ogc/gx.h"
GXTexRegionCallback GX_SetTexRegionCallback(GXTexRegionCallback cb);
# 4589 "d:/devkitPro/libogc/include/ogc/gx.h"
GXTlutRegionCallback GX_SetTlutRegionCallback(GXTlutRegionCallback cb);
# 4612 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitLightPos(GXLightObj *lit_obj,f32 x,f32 y,f32 z);
# 4626 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitLightColor(GXLightObj *lit_obj,GXColor col);
# 4650 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitLightDir(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz);
# 4668 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadLightObj(GXLightObj *lit_obj,u8 lit_id);
# 4685 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_LoadLightObjIdx(u32 litobjidx,u8 litid);
# 4713 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitLightDistAttn(GXLightObj *lit_obj,f32 ref_dist,f32 ref_brite,u8 dist_fn);
# 4751 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitLightAttn(GXLightObj *lit_obj,f32 a0,f32 a1,f32 a2,f32 k0,f32 k1,f32 k2);
# 4779 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitLightAttnA(GXLightObj *lit_obj,f32 a0,f32 a1,f32 a2);
# 4807 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitLightAttnK(GXLightObj *lit_obj,f32 k0,f32 k1,f32 k2);
# 4832 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitSpecularDirHA(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz,f32 hx,f32 hy,f32 hz);
# 4858 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitSpecularDir(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz);
# 4887 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitLightSpot(GXLightObj *lit_obj,f32 cut_off,u8 spotfn);

u32 GX_ReadClksPerVtx();
u32 GX_GetOverflowCount();
u32 GX_ResetOverflowCount();
# 4906 "d:/devkitPro/libogc/include/ogc/gx.h"
lwp_t GX_GetCurrentGXThread();
# 4924 "d:/devkitPro/libogc/include/ogc/gx.h"
lwp_t GX_SetCurrentGXThread();
# 4938 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_RestoreWriteGatherPipe();
# 4965 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetGPMetric(u32 perf0,u32 perf1);
# 4977 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_ClearGPMetric();
# 4987 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_InitXfRasMetric();
# 5004 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_ReadXfRasMetric(u32 *xfwaitin,u32 *xfwaitout,u32 *rasbusy,u32 *clks);
# 5016 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_ClearVCacheMetric();
# 5033 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_ReadVCacheMetric(u32 *check,u32 *miss,u32 *stall);
# 5047 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_SetVCacheMetric(u32 attr);
# 5067 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_GetGPStatus(u8 *overhi,u8 *underlow,u8 *readIdle,u8 *cmdIdle,u8 *brkpt);
# 5087 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_ReadGPMetric(u32 *cnt0,u32 *cnt1);
# 5106 "d:/devkitPro/libogc/include/ogc/gx.h"
void GX_ReadBoundingBox(u16 *top,u16 *bottom,u16 *left,u16 *right);
# 5136 "d:/devkitPro/libogc/include/ogc/gx.h"
volatile void* GX_RedirectWriteGatherPipe(void *ptr);
# 5253 "d:/devkitPro/libogc/include/ogc/gx.h"
   }
# 53 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/si.h" 1
# 66 "d:/devkitPro/libogc/include/ogc/si.h"
   extern "C" {


typedef void (*SICallback)(s32,u32);
typedef void (*RDSTHandler)(u32,void*);

u32 SI_Sync();
u32 SI_Busy();
u32 SI_IsChanBusy(s32 chan);
void SI_EnablePolling(u32 poll);
void SI_DisablePolling(u32 poll);
void SI_SetCommand(s32 chan,u32 cmd);
u32 SI_GetStatus(s32 chan);
u32 SI_GetResponse(s32 chan,void *buf);
u32 SI_GetResponseRaw(s32 chan);
void SI_RefreshSamplingRate();
u32 SI_Transfer(s32 chan,void *out,u32 out_len,void *in,u32 in_len,SICallback cb,u32 us_delay);
u32 SI_GetTypeAsync(s32 chan,SICallback cb);
u32 SI_GetType(s32 chan);
u32 SI_GetCommand(s32 chan);
void SI_TransferCommands();
u32 SI_RegisterPollingHandler(RDSTHandler handler);
u32 SI_UnregisterPollingHandler(RDSTHandler handler);
u32 SI_EnablePollingInterrupt(s32 enable);


   }
# 54 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/gx_struct.h" 1
# 55 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/irq.h" 1
# 41 "d:/devkitPro/libogc/include/ogc/irq.h"
# 1 "d:/devkitPro/libogc/include/ogc/context.h" 1
# 27 "d:/devkitPro/libogc/include/ogc/context.h"
   extern "C" {


typedef struct _excption_frame {
 u32 EXCPT_Number;
 u32 SRR0,SRR1;
 u32 GPR[32];
 u32 GQR[8];
 u32 CR, LR, CTR, XER, MSR, DAR;

 u16 state;
 u16 mode;

 f64 FPR[32];
 u64 FPSCR;
 f64 PSFPR[32];
} frame_context;


   }
# 42 "d:/devkitPro/libogc/include/ogc/irq.h" 2
# 125 "d:/devkitPro/libogc/include/ogc/irq.h"
   extern "C" {
# 134 "d:/devkitPro/libogc/include/ogc/irq.h"
typedef void (*raw_irq_handler_t)(u32 irq,void *ctx);
# 145 "d:/devkitPro/libogc/include/ogc/irq.h"
raw_irq_handler_t IRQ_Request(u32 nIrq,raw_irq_handler_t pHndl,void *pCtx);
# 154 "d:/devkitPro/libogc/include/ogc/irq.h"
raw_irq_handler_t IRQ_Free(u32 nIrq);
# 163 "d:/devkitPro/libogc/include/ogc/irq.h"
raw_irq_handler_t IRQ_GetHandler(u32 nIrq);







u32 IRQ_Disable(void);
# 180 "d:/devkitPro/libogc/include/ogc/irq.h"
void IRQ_Restore(u32 level);

void __MaskIrq(u32 nMask);
void __UnmaskIrq(u32 nMask);


   }
# 56 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/lwp.h" 1
# 57 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/mutex.h" 1
# 44 "d:/devkitPro/libogc/include/ogc/mutex.h"
 extern "C" {






typedef u32 mutex_t;
# 61 "d:/devkitPro/libogc/include/ogc/mutex.h"
s32 LWP_MutexInit(mutex_t *mutex,bool use_recursive);
# 70 "d:/devkitPro/libogc/include/ogc/mutex.h"
s32 LWP_MutexDestroy(mutex_t mutex);
# 79 "d:/devkitPro/libogc/include/ogc/mutex.h"
s32 LWP_MutexLock(mutex_t mutex);
# 88 "d:/devkitPro/libogc/include/ogc/mutex.h"
s32 LWP_MutexTryLock(mutex_t mutex);
# 97 "d:/devkitPro/libogc/include/ogc/mutex.h"
s32 LWP_MutexUnlock(mutex_t mutex);


 }
# 58 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/message.h" 1
# 51 "d:/devkitPro/libogc/include/ogc/message.h"
extern "C" {






typedef u32 mqbox_t;





typedef void* mqmsg_t;
# 75 "d:/devkitPro/libogc/include/ogc/message.h"
s32 MQ_Init(mqbox_t *mqbox,u32 count);
# 84 "d:/devkitPro/libogc/include/ogc/message.h"
void MQ_Close(mqbox_t mqbox);
# 95 "d:/devkitPro/libogc/include/ogc/message.h"
BOOL MQ_Send(mqbox_t mqbox,mqmsg_t msg,u32 flags);
# 106 "d:/devkitPro/libogc/include/ogc/message.h"
BOOL MQ_Jam(mqbox_t mqbox,mqmsg_t msg,u32 flags);
# 117 "d:/devkitPro/libogc/include/ogc/message.h"
BOOL MQ_Receive(mqbox_t mqbox,mqmsg_t *msg,u32 flags);


 }
# 59 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/semaphore.h" 1
# 45 "d:/devkitPro/libogc/include/ogc/semaphore.h"
extern "C" {






typedef u32 sem_t;
# 63 "d:/devkitPro/libogc/include/ogc/semaphore.h"
s32 LWP_SemInit(sem_t *sem,u32 start,u32 max);
# 72 "d:/devkitPro/libogc/include/ogc/semaphore.h"
s32 LWP_SemDestroy(sem_t sem);
# 81 "d:/devkitPro/libogc/include/ogc/semaphore.h"
s32 LWP_SemWait(sem_t sem);
# 90 "d:/devkitPro/libogc/include/ogc/semaphore.h"
s32 LWP_SemPost(sem_t sem);


 }
# 60 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/pad.h" 1
# 43 "d:/devkitPro/libogc/include/ogc/pad.h"
   extern "C" {


typedef struct _padstatus {
 u16 button;
 s8 stickX;
 s8 stickY;
 s8 substickX;
 s8 substickY;
 u8 triggerL;
 u8 triggerR;
 u8 analogA;
 u8 analogB;
 s8 err;
} PADStatus;

typedef void (*sampling_callback)(void);




u32 PAD_Init();
u32 PAD_Sync();
u32 PAD_Read(PADStatus *status);
u32 PAD_Reset(u32 mask);
u32 PAD_Recalibrate(u32 mask);
void PAD_Clamp(PADStatus *status);
void PAD_ControlMotor(s32 chan,u32 cmd);
void PAD_SetSpec(u32 spec);

u32 PAD_ScanPads();

u16 PAD_ButtonsUp(int pad);
u16 PAD_ButtonsDown(int pad);
u16 PAD_ButtonsHeld(int pad);

s8 PAD_SubStickX(int pad);
s8 PAD_SubStickY(int pad);

s8 PAD_StickX(int pad);
s8 PAD_StickY(int pad);

u8 PAD_TriggerL(int pad);
u8 PAD_TriggerR(int pad);


sampling_callback PAD_SetSamplingCallback(sampling_callback cb);




   }
# 61 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/tpl.h" 1



# 1 "d:/devkitPro/libogc/include/ogc/gx.h" 1
# 5 "d:/devkitPro/libogc/include/ogc/tpl.h" 2


   extern "C" {


typedef void* FHANDLE;


typedef struct _tplfile {
 int type;
 int ntextures;
 void *texdesc;
 FHANDLE tpl_file;
} TPLFile;

s32 TPL_OpenTPLFromFile(TPLFile* tdf, const char* file_name);
s32 TPL_OpenTPLFromMemory(TPLFile* tdf, void *memory,u32 len);
s32 TPL_GetTexture(TPLFile *tdf,s32 id,GXTexObj *texObj);
s32 TPL_GetTextureCI(TPLFile *tdf,s32 id,GXTexObj *texObj,GXTlutObj *tlutObj,u8 tluts);
s32 TPL_GetTextureInfo(TPLFile *tdf,s32 id,u32 *fmt,u16 *width,u16 *height);
void TPL_CloseTPLFile(TPLFile *tdf);


   }
# 62 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/system.h" 1
# 42 "d:/devkitPro/libogc/include/ogc/system.h"
# 1 "d:/devkitPro/libogc/include/gcutil.h" 1
# 43 "d:/devkitPro/libogc/include/ogc/system.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 1 3
# 10 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 1 3
# 15 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/newlib.h" 1 3
# 16 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/config.h" 1 3



# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/ieeefp.h" 1 3
# 5 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/config.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/features.h" 1 3
# 25 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/features.h" 3
extern "C" {
# 209 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/features.h" 3
}
# 6 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/config.h" 2 3
# 17 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 2 3
# 11 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 1 3
# 9 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
extern "C" {



# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 1 3
# 14 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 1 3
# 12 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_types.h" 1 3






# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 1 3
# 9 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
extern "C" {
# 26 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;
# 118 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
}
# 8 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_types.h" 2 3


typedef long long _fpos_t;


typedef long long _off_t;
# 13 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 47 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/lock.h" 3
extern int __libc_lock_init(int*,int);
extern int __libc_lock_close(int*);
extern int __libc_lock_acquire(int*);
extern int __libc_lock_try_acquire(int*);
extern int __libc_lock_release(int*);
# 14 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 2 3
# 24 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 3
typedef short __dev_t;




typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;
# 56 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 3
typedef int _ssize_t;






# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 353 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 64 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 15 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 89 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 105 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 169 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                     ;
  int (* _write) (struct _reent *, void *, const char *, int)
                            ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _fpos_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 273 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 305 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 580 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;


  struct _atexit *_atexit;
  struct _atexit _atexit0;


  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 818 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr __attribute__((__section__(".sdata")));
extern struct _reent *const _global_impure_ptr __attribute__((__section__(".sdata")));

void _reclaim_reent (struct _reent *);
# 841 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
}
# 12 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 2 3






# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/time.h" 1 3
# 19 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 2 3
# 27 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 212 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 3 4
typedef unsigned int size_t;
# 28 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 2 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 1 3
# 69 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 150 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 70 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/types.h" 1 3
# 19 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/types.h" 3
typedef long int __off_t;
typedef int __pid_t;

__extension__ typedef long long int __loff_t;
# 71 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 2 3
# 92 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;



typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;



typedef unsigned long clock_t;




typedef long time_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};


typedef long daddr_t;
typedef char * caddr_t;






typedef unsigned int ino_t;
# 163 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef _off_t off_t;
typedef __dev_t dev_t;
typedef __uid_t uid_t;
typedef __gid_t gid_t;





typedef int pid_t;







typedef long key_t;

typedef _ssize_t ssize_t;
# 196 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned int mode_t __attribute__ ((__mode__ (__SI__)));




typedef unsigned short nlink_t;
# 223 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef long fd_mask;







typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8))-1))/((sizeof (fd_mask) * 8)))];
} _types_fd_set;
# 254 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned long clockid_t;




typedef unsigned long timer_t;



typedef unsigned long useconds_t;
typedef long suseconds_t;

typedef __uint32_t fsblkcnt_t;
typedef __uint32_t fsfilcnt_t;
# 30 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 2 3

extern "C" {

struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
};

clock_t clock (void);
double difftime (time_t _time2, time_t _time1);
time_t mktime (struct tm *_timeptr);
time_t time (time_t *_timer);

char *asctime (const struct tm *_tblock);
char *ctime (const time_t *_time);
struct tm *gmtime (const time_t *_timer);
struct tm *localtime (const time_t *_timer);

size_t strftime (char *_s, size_t _maxsize, const char *_fmt, const struct tm *_t);

char *asctime_r (const struct tm *, char *);
char *ctime_r (const time_t *, char *);
struct tm *gmtime_r (const time_t *, struct tm *);
struct tm *localtime_r (const time_t *, struct tm *);

}


extern "C" {



char *strptime (const char *, const char *, struct tm *);
void tzset (void);
void _tzset_r (struct _reent *);

typedef struct __tzrule_struct
{
  char ch;
  int m;
  int n;
  int d;
  int s;
  time_t change;
  long offset;
} __tzrule_type;

typedef struct __tzinfo_struct
{
  int __tznorth;
  int __tzyear;
  __tzrule_type __tzrule[2];
} __tzinfo_type;

__tzinfo_type *__gettzinfo (void);
# 118 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
extern long _timezone;
extern int _daylight;
extern char *_tzname[2];
# 129 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
}
# 195 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
extern "C" {
# 273 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
}
# 44 "d:/devkitPro/libogc/include/ogc/system.h" 2
# 130 "d:/devkitPro/libogc/include/ogc/system.h"
   extern "C" {







typedef u32 syswd_t;
# 154 "d:/devkitPro/libogc/include/ogc/system.h"
typedef struct _syssram syssram;

struct _syssram {
 u16 checksum;
 u16 checksum_inv;
 u32 ead0;
 u32 ead1;
 u32 counter_bias;
 s8 display_offsetH;
 u8 ntd;
 u8 lang;
 u8 flags;
} __attribute__((packed));
# 180 "d:/devkitPro/libogc/include/ogc/system.h"
typedef struct _syssramex syssramex;

struct _syssramex {
 u8 flash_id[2][12];
 u32 wirelessKbd_id;
 u16 wirelessPad_id[4];
 u8 dvderr_code;
 u8 __padding0;
 u16 flashID_chksum[2];
 u8 __padding1[4];
} __attribute__((packed));

typedef void (*alarmcallback)(syswd_t alarm,void *cb_arg);

typedef struct _sys_fontheader sys_fontheader;

struct _sys_fontheader {
 u16 font_type;
 u16 first_char;
 u16 last_char;
 u16 inval_char;
 u16 asc;
 u16 desc;
 u16 width;
 u16 leading;
    u16 cell_width;
    u16 cell_height;
    u32 sheet_size;
    u16 sheet_format;
    u16 sheet_column;
    u16 sheet_row;
    u16 sheet_width;
    u16 sheet_height;
    u16 width_table;
    u32 sheet_image;
    u32 sheet_fullsize;
    u8 c0;
    u8 c1;
    u8 c2;
    u8 c3;
} __attribute__((packed));

typedef void (*resetcallback)(void);
typedef void (*powercallback)(void);
typedef s32 (*resetfunction)(s32 final);
typedef struct _sys_resetinfo sys_resetinfo;

struct _sys_resetinfo {
 lwp_node node;
 resetfunction func;
 u32 prio;
};






void SYS_Init();
# 248 "d:/devkitPro/libogc/include/ogc/system.h"
void* SYS_AllocateFramebuffer(GXRModeObj *rmode);


void SYS_ProtectRange(u32 chan,void *addr,u32 bytes,u32 cntrl);
void SYS_StartPMC(u32 mcr0val,u32 mcr1val);
void SYS_DumpPMC();
void SYS_StopPMC();
# 263 "d:/devkitPro/libogc/include/ogc/system.h"
s32 SYS_CreateAlarm(syswd_t *thealarm);
# 274 "d:/devkitPro/libogc/include/ogc/system.h"
s32 SYS_SetAlarm(syswd_t thealarm,const struct timespec *tp,alarmcallback cb,void *cbarg);
# 286 "d:/devkitPro/libogc/include/ogc/system.h"
s32 SYS_SetPeriodicAlarm(syswd_t thealarm,const struct timespec *tp_start,const struct timespec *tp_period,alarmcallback cb,void *cbarg);
# 295 "d:/devkitPro/libogc/include/ogc/system.h"
s32 SYS_RemoveAlarm(syswd_t thealarm);
# 304 "d:/devkitPro/libogc/include/ogc/system.h"
s32 SYS_CancelAlarm(syswd_t thealarm);


void SYS_SetWirelessID(u32 chan,u32 id);
u32 SYS_GetWirelessID(u32 chan);
u32 SYS_GetFontEncoding();
u32 SYS_InitFont(sys_fontheader *font_data);
void SYS_GetFontTexture(s32 c,void **image,s32 *xpos,s32 *ypos,s32 *width);
void SYS_GetFontTexel(s32 c,void *image,s32 pos,s32 stride,s32 *width);
void SYS_ResetSystem(s32 reset,u32 reset_code,s32 force_menu);
void SYS_RegisterResetFunc(sys_resetinfo *info);
void SYS_UnregisterResetFunc(sys_resetinfo *info);
void SYS_SwitchFiber(u32 arg0,u32 arg1,u32 arg2,u32 arg3,u32 pc,u32 newsp);

void* SYS_GetArena1Lo();
void SYS_SetArena1Lo(void *newLo);
void* SYS_GetArena1Hi();
void SYS_SetArena1Hi(void *newHi);
u32 SYS_GetArena1Size();

resetcallback SYS_SetResetCallback(resetcallback cb);

u32 SYS_ResetButtonDown();


u32 SYS_GetHollywoodRevision();
void* SYS_GetArena2Lo();
void SYS_SetArena2Lo(void *newLo);
void* SYS_GetArena2Hi();
void SYS_SetArena2Hi(void *newHi);
u32 SYS_GetArena2Size();
powercallback SYS_SetPowerCallback(powercallback cb);


void kprintf(const char *str, ...);


   }
# 63 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/video.h" 1
# 42 "d:/devkitPro/libogc/include/ogc/video.h"
# 1 "d:/devkitPro/libogc/include/ogc/video_types.h" 1
# 152 "d:/devkitPro/libogc/include/ogc/video_types.h"
extern GXRModeObj TVNtsc240Ds;
extern GXRModeObj TVNtsc240DsAa;
extern GXRModeObj TVNtsc240Int;
extern GXRModeObj TVNtsc240IntAa;
extern GXRModeObj TVNtsc480Int;
extern GXRModeObj TVNtsc480IntDf;
extern GXRModeObj TVNtsc480IntAa;
extern GXRModeObj TVNtsc480Prog;
extern GXRModeObj TVNtsc480ProgSoft;
extern GXRModeObj TVNtsc480ProgAa;
extern GXRModeObj TVMpal240Ds;
extern GXRModeObj TVMpal240DsAa;
extern GXRModeObj TVMpal480IntDf;
extern GXRModeObj TVMpal480IntAa;
extern GXRModeObj TVMpal480Prog;
extern GXRModeObj TVPal264Ds;
extern GXRModeObj TVPal264DsAa;
extern GXRModeObj TVPal264Int;
extern GXRModeObj TVPal264IntAa;
extern GXRModeObj TVPal524IntAa;
extern GXRModeObj TVPal528Int;
extern GXRModeObj TVPal528IntDf;
extern GXRModeObj TVPal576IntDfScale;
extern GXRModeObj TVPal576ProgScale;
extern GXRModeObj TVEurgb60Hz240Ds;
extern GXRModeObj TVEurgb60Hz240DsAa;
extern GXRModeObj TVEurgb60Hz240Int;
extern GXRModeObj TVEurgb60Hz240IntAa;
extern GXRModeObj TVEurgb60Hz480Int;
extern GXRModeObj TVEurgb60Hz480IntDf;
extern GXRModeObj TVEurgb60Hz480IntAa;
extern GXRModeObj TVEurgb60Hz480Prog;
extern GXRModeObj TVEurgb60Hz480ProgSoft;
extern GXRModeObj TVEurgb60Hz480ProgAa;
# 43 "d:/devkitPro/libogc/include/ogc/video.h" 2


   extern "C" {
# 54 "d:/devkitPro/libogc/include/ogc/video.h"
typedef void (*VIRetraceCallback)(u32 retraceCnt);

typedef void (*VIPositionCallback)(u32 posX,u32 posY);

void* VIDEO_GetNextFramebuffer();
void* VIDEO_GetCurrentFramebuffer();
# 68 "d:/devkitPro/libogc/include/ogc/video.h"
void VIDEO_Init();
# 77 "d:/devkitPro/libogc/include/ogc/video.h"
void VIDEO_Flush();
# 88 "d:/devkitPro/libogc/include/ogc/video.h"
void VIDEO_SetBlack(bool black);
# 97 "d:/devkitPro/libogc/include/ogc/video.h"
u32 VIDEO_GetNextField();
# 106 "d:/devkitPro/libogc/include/ogc/video.h"
u32 VIDEO_GetCurrentLine();
# 115 "d:/devkitPro/libogc/include/ogc/video.h"
u32 VIDEO_GetCurrentTvMode();
# 126 "d:/devkitPro/libogc/include/ogc/video.h"
void VIDEO_Configure(GXRModeObj *rmode);

u32 VIDEO_GetFrameBufferSize(GXRModeObj *rmode);
# 140 "d:/devkitPro/libogc/include/ogc/video.h"
void VIDEO_ClearFrameBuffer(GXRModeObj *rmode,void *fb,u32 color);
# 149 "d:/devkitPro/libogc/include/ogc/video.h"
void VIDEO_WaitVSync(void);
# 158 "d:/devkitPro/libogc/include/ogc/video.h"
void VIDEO_SetNextFramebuffer(void *fb);
# 167 "d:/devkitPro/libogc/include/ogc/video.h"
void VIDEO_SetNextRightFramebuffer(void *fb);
# 178 "d:/devkitPro/libogc/include/ogc/video.h"
VIRetraceCallback VIDEO_SetPreRetraceCallback(VIRetraceCallback callback);
# 189 "d:/devkitPro/libogc/include/ogc/video.h"
VIRetraceCallback VIDEO_SetPostRetraceCallback(VIRetraceCallback callback);
# 198 "d:/devkitPro/libogc/include/ogc/video.h"
u32 VIDEO_HaveComponentCable(void);

GXRModeObj * VIDEO_GetPreferredMode(GXRModeObj *mode);


   }
# 64 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/usbgecko.h" 1






   extern "C" {


void usb_flush(s32 chn);
int usb_isgeckoalive(s32 chn);
int usb_recvbuffer(s32 chn,void *buffer,int size);
int usb_sendbuffer(s32 chn,const void *buffer,int size);
int usb_recvbuffer_safe(s32 chn,void *buffer,int size);
int usb_sendbuffer_safe(s32 chn,const void *buffer,int size);
int usb_recvbuffer_ex(s32 chn,void *buffer,int size, int retries);
int usb_sendbuffer_ex(s32 chn,const void *buffer,int size, int retries);
int usb_recvbuffer_safe_ex(s32 chn,void *buffer,int size, int retries);
int usb_sendbuffer_safe_ex(s32 chn,const void *buffer,int size, int retries);
int usb_flashread(s32 chn, u32 offset, void *buffer, size_t length);
int usb_flashwrite(s32 chn, u32 offset, const void *buffer, size_t length);
int usb_flashverify(s32 chn);


   }
# 65 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/video_types.h" 1
# 66 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/texconv.h" 1
# 42 "d:/devkitPro/libogc/include/ogc/texconv.h"
   extern "C" {


void MakeTexture565(const void *src,void *dst,s32 width,s32 height);


   }
# 67 "d:/devkitPro/libogc/include/gccore.h" 2


# 1 "d:/devkitPro/libogc/include/ogc/ipc.h" 1
# 53 "d:/devkitPro/libogc/include/ogc/ipc.h"
   extern "C" {


typedef struct _ioctlv
{
 void *data;
 u32 len;
} ioctlv;

void __IPC_Reinitialize(void);

typedef s32 (*ipccallback)(s32 result,void *usrdata);

s32 iosCreateHeap(s32 size);
void* iosAlloc(s32 hid,s32 size);
void iosFree(s32 hid,void *ptr);

void* IPC_GetBufferLo();
void* IPC_GetBufferHi();
void IPC_SetBufferLo(void *bufferlo);
void IPC_SetBufferHi(void *bufferhi);

s32 IOS_Open(const char *filepath,u32 mode);
s32 IOS_OpenAsync(const char *filepath,u32 mode,ipccallback ipc_cb,void *usrdata);

s32 IOS_Close(s32 fd);
s32 IOS_CloseAsync(s32 fd,ipccallback ipc_cb,void *usrdata);

s32 IOS_Seek(s32 fd,s32 where,s32 whence);
s32 IOS_SeekAsync(s32 fd,s32 where,s32 whence,ipccallback ipc_cb,void *usrdata);
s32 IOS_Read(s32 fd,void *buf,s32 len);
s32 IOS_ReadAsync(s32 fd,void *buf,s32 len,ipccallback ipc_cb,void *usrdata);
s32 IOS_Write(s32 fd,const void *buf,s32 len);
s32 IOS_WriteAsync(s32 fd,const void *buf,s32 len,ipccallback ipc_cb,void *usrdata);

s32 IOS_Ioctl(s32 fd,s32 ioctl,void *buffer_in,s32 len_in,void *buffer_io,s32 len_io);
s32 IOS_IoctlAsync(s32 fd,s32 ioctl,void *buffer_in,s32 len_in,void *buffer_io,s32 len_io,ipccallback ipc_cb,void *usrdata);
s32 IOS_Ioctlv(s32 fd,s32 ioctl,s32 cnt_in,s32 cnt_io,ioctlv *argv);
s32 IOS_IoctlvAsync(s32 fd,s32 ioctl,s32 cnt_in,s32 cnt_io,ioctlv *argv,ipccallback ipc_cb,void *usrdata);

s32 IOS_IoctlvFormat(s32 hId,s32 fd,s32 ioctl,const char *format,...);
s32 IOS_IoctlvFormatAsync(s32 hId,s32 fd,s32 ioctl,ipccallback usr_cb,void *usr_data,const char *format,...);

s32 IOS_IoctlvReboot(s32 fd,s32 ioctl,s32 cnt_in,s32 cnt_io,ioctlv *argv);
s32 IOS_IoctlvRebootBackground(s32 fd,s32 ioctl,s32 cnt_in,s32 cnt_io,ioctlv *argv);


   }
# 70 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/es.h" 1
# 57 "d:/devkitPro/libogc/include/ogc/es.h"
   extern "C" {


typedef u32 sigtype;
typedef sigtype sig_header;
typedef sig_header signed_blob;

typedef u8 sha1[20];
typedef u8 aeskey[16];

typedef struct _sig_rsa2048 {
 sigtype type;
 u8 sig[256];
 u8 fill[60];
} __attribute__((packed)) sig_rsa2048;

typedef struct _sig_rsa4096 {
 sigtype type;
 u8 sig[512];
 u8 fill[60];
} __attribute__((packed)) sig_rsa4096;

typedef struct _sig_ecdsa {
 sigtype type;
 u8 sig[60];
 u8 fill[64];
} __attribute__((packed)) sig_ecdsa;

typedef char sig_issuer[0x40];

typedef struct _tiklimit {
 u32 tag;
 u32 value;
} __attribute__((packed)) tiklimit;

typedef struct _tikview {
 u32 view;
 u64 ticketid;
 u32 devicetype;
 u64 titleid;
 u16 access_mask;
 u8 reserved[0x3c];
 u8 cidx_mask[0x40];
 u16 padding;
 tiklimit limits[8];
} __attribute__((packed)) tikview;

typedef struct _tik {
 sig_issuer issuer;
 u8 fill[63];
 aeskey cipher_title_key;
 u8 fill2;
 u64 ticketid;
 u32 devicetype;
 u64 titleid;
 u16 access_mask;
 u8 reserved[0x3c];
 u8 cidx_mask[0x40];
 u16 padding;
 tiklimit limits[8];
} __attribute__((packed)) tik;

typedef struct _tmd_content {
 u32 cid;
 u16 index;
 u16 type;
 u64 size;
 sha1 hash;
} __attribute__((packed)) tmd_content;

typedef struct _tmd {
 sig_issuer issuer;
 u8 version;
 u8 ca_crl_version;
 u8 signer_crl_version;
 u8 fill2;
 u64 sys_version;
 u64 title_id;
 u32 title_type;
 u16 group_id;
 u16 zero;
 u16 region;
 u8 ratings[16];
 u8 reserved[12];
 u8 ipc_mask[12];
 u8 reserved2[18];
 u32 access_rights;
 u16 title_version;
 u16 num_contents;
 u16 boot_index;
 u16 fill3;


 tmd_content contents[];
} __attribute__((packed)) tmd;

typedef struct _tmd_view_content
{
  u32 cid;
  u16 index;
  u16 type;
  u64 size;
} __attribute__((packed)) tmd_view_content;

typedef struct _tmdview
{
 u8 version;
 u8 filler[3];
 u64 sys_version;
 u64 title_id;
 u32 title_type;
 u16 group_id;
 u8 reserved[0x3e];
 u16 title_version;
 u16 num_contents;
 tmd_view_content contents[];
}__attribute__((packed)) tmd_view;

typedef struct _cert_header {
 sig_issuer issuer;
 u32 cert_type;
 char cert_name[64];
 u32 cert_id;
} __attribute__((packed)) cert_header;

typedef struct _cert_rsa2048 {
 sig_issuer issuer;
 u32 cert_type;
 char cert_name[64];
 u32 cert_id;
 u8 modulus[256];
 u32 exponent;
 u8 pad[0x34];
} __attribute__((packed)) cert_rsa2048;

typedef struct _cert_rsa4096 {
 sig_issuer issuer;
 u32 cert_type;
 char cert_name[64];
 u32 cert_id;
 u8 modulus[512];
 u32 exponent;
 u8 pad[0x34];
} __attribute__((packed)) cert_rsa4096;

typedef struct _cert_ecdsa {
 sig_issuer issuer;
 u32 cert_type;
 char cert_name[64];
 u32 cert_id;
 u8 r[30];
 u8 s[30];
 u8 pad[0x3c];
} __attribute__((packed)) cert_ecdsa;
# 253 "d:/devkitPro/libogc/include/ogc/es.h"
s32 __ES_Init(void);
s32 __ES_Close(void);
s32 __ES_Reset(void);
s32 ES_GetTitleID(u64 *titleID);
s32 ES_SetUID(u64 uid);
s32 ES_GetDataDir(u64 titleID, char *filepath);
s32 ES_GetNumTicketViews(u64 titleID, u32 *cnt);
s32 ES_GetTicketViews(u64 titleID, tikview *views, u32 cnt);
s32 ES_GetNumOwnedTitles(u32 *cnt);
s32 ES_GetOwnedTitles(u64 *titles, u32 cnt);
s32 ES_GetNumTitles(u32 *cnt);
s32 ES_GetTitles(u64 *titles, u32 cnt);
s32 ES_GetNumStoredTMDContents(const signed_blob *stmd, u32 tmd_size, u32 *cnt);
s32 ES_GetStoredTMDContents(const signed_blob *stmd, u32 tmd_size, u32 *contents, u32 cnt);
s32 ES_GetStoredTMDSize(u64 titleID, u32 *size);
s32 ES_GetStoredTMD(u64 titleID, signed_blob *stmd, u32 size);
s32 ES_GetTitleContentsCount(u64 titleID, u32 *num);
s32 ES_GetTitleContents(u64 titleID, u8 *data, u32 size);
s32 ES_GetTMDViewSize(u64 titleID, u32 *size);
s32 ES_GetTMDView(u64 titleID, u8 *data, u32 size);
s32 ES_GetNumSharedContents(u32 *cnt);
s32 ES_GetSharedContents(sha1 *contents, u32 cnt);
s32 ES_LaunchTitle(u64 titleID, const tikview *view);
s32 ES_LaunchTitleBackground(u64 titleID, const tikview *view);
s32 ES_Identify(const signed_blob *certificates, u32 certificates_size, const signed_blob *tmd, u32 tmd_size, const signed_blob *ticket, u32 ticket_size, u32 *keyid);
s32 ES_AddTicket(const signed_blob *tik, u32 tik_size, const signed_blob *certificates, u32 certificates_size, const signed_blob *crl, u32 crl_size);
s32 ES_DeleteTicket(const tikview *view);
s32 ES_AddTitleTMD(const signed_blob *tmd, u32 tmd_size);
s32 ES_AddTitleStart(const signed_blob *tmd, u32 tmd_size, const signed_blob *certificatess, u32 certificatess_size, const signed_blob *crl, u32 crl_size);
s32 ES_AddContentStart(u64 titleID, u32 cid);
s32 ES_AddContentData(s32 cid, u8 *data, u32 data_size);
s32 ES_AddContentFinish(u32 cid);
s32 ES_AddTitleFinish(void);
s32 ES_AddTitleCancel(void);
s32 ES_ImportBoot(const signed_blob *tik, u32 tik_size,const signed_blob *tik_certs, u32 tik_certs_size,const signed_blob *tmd, u32 tmd_size,const signed_blob *tmd_certs, u32 tmd_certs_size,const u8 *content, u32 content_size);
s32 ES_OpenContent(u16 index);
s32 ES_OpenTitleContent(u64 titleID, tikview *views, u16 index);
s32 ES_ReadContent(s32 cfd, u8 *data, u32 data_size);
s32 ES_SeekContent(s32 cfd, s32 where, s32 whence);
s32 ES_CloseContent(s32 cfd);
s32 ES_DeleteTitle(u64 titleID);
s32 ES_DeleteTitleContent(u64 titleID);
s32 ES_Encrypt(u32 keynum, u8 *iv, u8 *source, u32 size, u8 *dest);
s32 ES_Decrypt(u32 keynum, u8 *iv, u8 *source, u32 size, u8 *dest);
s32 ES_Sign(u8 *source, u32 size, u8 *sig, u8 *certs);
s32 ES_GetDeviceCert(u8 *outbuf);
s32 ES_GetDeviceID(u32 *device_id);
s32 ES_GetBoot2Version(u32 *version);
signed_blob *ES_NextCert(const signed_blob *certs);


   }
# 71 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/stm.h" 1
# 47 "d:/devkitPro/libogc/include/ogc/stm.h"
   extern "C" {


typedef void (*stmcallback)(u32 event);

s32 __STM_Init();
s32 __STM_Close();
s32 STM_ShutdownToStandby();
s32 STM_ShutdownToIdle();
s32 STM_SetLedMode(u32 mode);
s32 STM_RebootSystem();
stmcallback STM_RegisterEventHandler(stmcallback newhandler);


   }
# 72 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/ios.h" 1
# 45 "d:/devkitPro/libogc/include/ogc/ios.h"
   extern "C" {


s32 __IOS_InitializeSubsystems(void);
s32 __IOS_ShutdownSubsystems(void);
s32 __IOS_LoadStartupIOS(void);
s32 __IOS_LaunchNewIOS(int version);
s32 IOS_GetPreferredVersion(void);
s32 IOS_ReloadIOS(int version);
s32 IOS_GetVersion();
s32 IOS_GetRevision();
s32 IOS_GetRevisionMajor();
s32 IOS_GetRevisionMinor();


   }
# 73 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/usb.h" 1
# 98 "d:/devkitPro/libogc/include/ogc/usb.h"
   extern "C" {


typedef struct _usbendpointdesc
{
 u8 bLength;
 u8 bDescriptorType;
 u8 bEndpointAddress;
 u8 bmAttributes;
 u16 wMaxPacketSize;
 u8 bInterval;
} __attribute__((packed)) usb_endpointdesc;

typedef struct _usbinterfacedesc
{
 u8 bLength;
 u8 bDescriptorType;
 u8 bInterfaceNumber;
 u8 bAlternateSetting;
 u8 bNumEndpoints;
 u8 bInterfaceClass;
 u8 bInterfaceSubClass;
 u8 bInterfaceProtocol;
 u8 iInterface;
 u8 *extra;
 u16 extra_size;
 struct _usbendpointdesc *endpoints;
} __attribute__((packed)) usb_interfacedesc;

typedef struct _usbconfdesc
{
 u8 bLength;
 u8 bDescriptorType;
 u16 wTotalLength;
 u8 bNumInterfaces;
 u8 bConfigurationValue;
 u8 iConfiguration;
 u8 bmAttributes;
 u8 bMaxPower;
 struct _usbinterfacedesc *interfaces;
} __attribute__((packed)) usb_configurationdesc;

typedef struct _usbdevdesc
{
 u8 bLength;
 u8 bDescriptorType;
 u16 bcdUSB;
 u8 bDeviceClass;
 u8 bDeviceSubClass;
 u8 bDeviceProtocol;
 u8 bMaxPacketSize0;
 u16 idVendor;
 u16 idProduct;
 u16 bcdDevice;
 u8 iManufacturer;
 u8 iProduct;
 u8 iSerialNumber;
 u8 bNumConfigurations;
 struct _usbconfdesc *configurations;
} __attribute__((packed)) usb_devdesc;

typedef struct _usbhiddesc
{
 u8 bLength;
 u8 bDescriptorType;
 u16 bcdHID;
 u8 bCountryCode;
 u8 bNumDescriptors;
 struct {
  u8 bDescriptorType;
  u16 wDescriptorLength;
 } __attribute__((packed)) descr[1];
} __attribute__((packed)) usb_hiddesc;

typedef struct _usb_device_entry {
 s32 device_id;
 u16 vid;
 u16 pid;
 u32 token;
} usb_device_entry;

typedef s32 (*usbcallback)(s32 result,void *usrdata);

s32 USB_Initialize();
s32 USB_Deinitialize();

s32 USB_OpenDevice(s32 device_id,u16 vid,u16 pid,s32 *fd);
s32 USB_CloseDevice(s32 *fd);
s32 USB_CloseDeviceAsync(s32 *fd,usbcallback cb,void *usrdata);

s32 USB_GetDescriptors(s32 fd, usb_devdesc *udd);
void USB_FreeDescriptors(usb_devdesc *udd);

s32 USB_GetGenericDescriptor(s32 fd,u8 type,u8 index,u8 interface,void *data,u32 size);
s32 USB_GetHIDDescriptor(s32 fd,u8 interface,usb_hiddesc *uhd,u32 size);

s32 USB_GetDeviceDescription(s32 fd,usb_devdesc *devdesc);
s32 USB_DeviceRemovalNotifyAsync(s32 fd,usbcallback cb,void *userdata);
s32 USB_DeviceChangeNotifyAsync(u8 interface_class,usbcallback cb,void *userdata);

s32 USB_SuspendDevice(s32 fd);
s32 USB_ResumeDevice(s32 fd);

s32 USB_ReadIsoMsg(s32 fd,u8 bEndpoint,u8 bPackets,u16 *rpPacketSizes,void *rpData);
s32 USB_ReadIsoMsgAsync(s32 fd,u8 bEndpoint,u8 bPackets,u16 *rpPacketSizes,void *rpData,usbcallback cb,void *userdata);

s32 USB_ReadIntrMsg(s32 fd,u8 bEndpoint,u16 wLength,void *rpData);
s32 USB_ReadIntrMsgAsync(s32 fd,u8 bEndpoint,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_ReadBlkMsg(s32 fd,u8 bEndpoint,u16 wLength,void *rpData);
s32 USB_ReadBlkMsgAsync(s32 fd,u8 bEndpoint,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_ReadCtrlMsg(s32 fd,u8 bmRequestType,u8 bmRequest,u16 wValue,u16 wIndex,u16 wLength,void *rpData);
s32 USB_ReadCtrlMsgAsync(s32 fd,u8 bmRequestType,u8 bmRequest,u16 wValue,u16 wIndex,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_WriteIsoMsg(s32 fd,u8 bEndpoint,u8 bPackets,u16 *rpPacketSizes,void *rpData);
s32 USB_WriteIsoMsgAsync(s32 fd,u8 bEndpoint,u8 bPackets,u16 *rpPacketSizes,void *rpData,usbcallback cb,void *userdata);

s32 USB_WriteIntrMsg(s32 fd,u8 bEndpoint,u16 wLength,void *rpData);
s32 USB_WriteIntrMsgAsync(s32 fd,u8 bEndpoint,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_WriteBlkMsg(s32 fd,u8 bEndpoint,u16 wLength,void *rpData);
s32 USB_WriteBlkMsgAsync(s32 fd,u8 bEndpoint,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_WriteCtrlMsg(s32 fd,u8 bmRequestType,u8 bmRequest,u16 wValue,u16 wIndex,u16 wLength,void *rpData);
s32 USB_WriteCtrlMsgAsync(s32 fd,u8 bmRequestType,u8 bmRequest,u16 wValue,u16 wIndex,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_GetConfiguration(s32 fd, u8 *configuration);
s32 USB_SetConfiguration(s32 fd, u8 configuration);
s32 USB_SetAlternativeInterface(s32 fd, u8 interface, u8 alternateSetting);
s32 USB_ClearHalt(s32 fd, u8 endpointAddress);
s32 USB_GetDeviceList(usb_device_entry *descr_buffer,u8 num_descr,u8 interface_class,u8 *cnt_descr);

s32 USB_GetAsciiString(s32 fd,u8 bIndex,u16 wLangID,u16 wLength,void *rpData);


   }
# 74 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/isfs.h" 1
# 19 "d:/devkitPro/libogc/include/ogc/isfs.h"
   extern "C" {


typedef struct _fstats
{
 u32 file_length;
 u32 file_pos;
} fstats;

typedef s32 (*isfscallback)(s32 result,void *usrdata);

s32 ISFS_Initialize();
s32 ISFS_Deinitialize();

s32 ISFS_Open(const char *filepath,u8 mode);
s32 ISFS_OpenAsync(const char *filepath,u8 mode,isfscallback cb,void *usrdata);
s32 ISFS_Close(s32 fd);
s32 ISFS_CloseAsync(s32 fd,isfscallback cb,void *usrdata);
s32 ISFS_Delete(const char *filepath);
s32 ISFS_DeleteAsync(const char *filepath,isfscallback cb,void *usrdata);
s32 ISFS_ReadDir(const char *filepath,char *name_list,u32 *num);
s32 ISFS_ReadDirAsync(const char *filepath,char *name_list,u32 *num,isfscallback cb,void *usrdata);
s32 ISFS_CreateFile(const char *filepath,u8 attributes,u8 owner_perm,u8 group_perm,u8 other_perm);
s32 ISFS_CreateFileAsync(const char *filepath,u8 attributes,u8 owner_perm,u8 group_perm,u8 other_perm,isfscallback cb,void *usrdata);
s32 ISFS_Write(s32 fd,const void *buffer,u32 length);
s32 ISFS_WriteAsync(s32 fd,const void *buffer,u32 length,isfscallback cb,void *usrdata);
s32 ISFS_Read(s32 fd,void *buffer,u32 length);
s32 ISFS_ReadAsync(s32 fd,void *buffer,u32 length,isfscallback cb,void *usrdata);
s32 ISFS_Seek(s32 fd,s32 where,s32 whence);
s32 ISFS_SeekAsync(s32 fd,s32 where,s32 whence,isfscallback cb,void *usrdata);
s32 ISFS_CreateDir(const char *filepath,u8 attributes,u8 owner_perm,u8 group_perm,u8 other_perm);
s32 ISFS_CreateDirAsync(const char *filepath,u8 attributes,u8 owner_perm,u8 group_perm,u8 other_perm,isfscallback cb,void *usrdata);
s32 ISFS_GetStats(void *stats);
s32 ISFS_GetStatsAsync(void *stats,isfscallback cb,void *usrdata);
s32 ISFS_GetFileStats(s32 fd,fstats *status);
s32 ISFS_GetFileStatsAsync(s32 fd,fstats *status,isfscallback cb,void *usrdata);
s32 ISFS_GetAttr(const char *filepath,u32 *ownerID,u16 *groupID,u8 *attributes,u8 *ownerperm,u8 *groupperm,u8 *otherperm);
s32 ISFS_GetAttrAsync(const char *filepath,u32 *ownerID,u16 *groupID,u8 *attributes,u8 *ownerperm,u8 *groupperm,u8 *otherperm,isfscallback cb,void *usrdata);
s32 ISFS_Rename(const char *filepathOld,const char *filepathNew);
s32 ISFS_RenameAsync(const char *filepathOld,const char *filepathNew,isfscallback cb,void *usrdata);
s32 ISFS_SetAttr(const char *filepath,u32 ownerID,u16 groupID,u8 attributes,u8 ownerperm,u8 groupperm,u8 otherperm);
s32 ISFS_SetAttrAsync(const char *filepath,u32 ownerID,u16 groupID,u8 attributes,u8 ownerperm,u8 groupperm,u8 otherperm,isfscallback cb,void *usrdata);
s32 ISFS_GetUsage(const char* filepath, u32* usage1, u32* usage2);
s32 ISFS_GetUsageAsync(const char* filepath, u32* usage1, u32* usage2,isfscallback cb,void *usrdata);


   }
# 75 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/conf.h" 1
# 47 "d:/devkitPro/libogc/include/ogc/conf.h"
   extern "C" {


enum {
 CONF_BIGARRAY = 1,
 CONF_SMALLARRAY,
 CONF_BYTE,
 CONF_SHORT,
 CONF_LONG,
 CONF_BOOL = 7
};

enum {
 CONF_VIDEO_NTSC = 0,
 CONF_VIDEO_PAL,
 CONF_VIDEO_MPAL
};

enum {
 CONF_REGION_JP = 0,
 CONF_REGION_US = 1,
 CONF_REGION_EU = 2,
 CONF_REGION_KR = 4,
 CONF_REGION_CN = 5
};

enum {
 CONF_AREA_JPN = 0,
 CONF_AREA_USA,
 CONF_AREA_EUR,
 CONF_AREA_AUS,
 CONF_AREA_BRA,
 CONF_AREA_TWN,
 CONF_AREA_ROC,
 CONF_AREA_KOR,
 CONF_AREA_HKG,
 CONF_AREA_ASI,
 CONF_AREA_LTN,
 CONF_AREA_SAF,
 CONF_AREA_CHN
};

enum {
 CONF_SHUTDOWN_STANDBY = 0,
 CONF_SHUTDOWN_IDLE
};

enum {
 CONF_LED_OFF = 0,
 CONF_LED_DIM,
 CONF_LED_BRIGHT
};

enum {
 CONF_SOUND_MONO = 0,
 CONF_SOUND_STEREO,
 CONF_SOUND_SURROUND
};

enum {
 CONF_LANG_JAPANESE = 0,
 CONF_LANG_ENGLISH,
 CONF_LANG_GERMAN,
 CONF_LANG_FRENCH,
 CONF_LANG_SPANISH,
 CONF_LANG_ITALIAN,
 CONF_LANG_DUTCH,
 CONF_LANG_SIMP_CHINESE,
 CONF_LANG_TRAD_CHINESE,
 CONF_LANG_KOREAN
};

enum {
 CONF_ASPECT_4_3 = 0,
 CONF_ASPECT_16_9
};

enum {
 CONF_SENSORBAR_BOTTOM = 0,
 CONF_SENSORBAR_TOP
};




typedef struct _conf_pad_device conf_pad_device;

struct _conf_pad_device {
 u8 bdaddr[6];
 char name[0x40];
} __attribute__((packed));

typedef struct _conf_pads conf_pads;

struct _conf_pads {
 u8 num_registered;
 conf_pad_device registered[10];
 conf_pad_device active[4];
 conf_pad_device balance_board;
 conf_pad_device unknown;
} __attribute__((packed));

s32 CONF_Init(void);
s32 CONF_GetLength(const char *name);
s32 CONF_GetType(const char *name);
s32 CONF_Get(const char *name, void *buffer, u32 length);
s32 CONF_GetShutdownMode(void);
s32 CONF_GetIdleLedMode(void);
s32 CONF_GetProgressiveScan(void);
s32 CONF_GetEuRGB60(void);
s32 CONF_GetIRSensitivity(void);
s32 CONF_GetSensorBarPosition(void);
s32 CONF_GetPadSpeakerVolume(void);
s32 CONF_GetPadMotorMode(void);
s32 CONF_GetSoundMode(void);
s32 CONF_GetLanguage(void);
s32 CONF_GetCounterBias(u32 *bias);
s32 CONF_GetScreenSaverMode(void);
s32 CONF_GetDisplayOffsetH(s8 *offset);
s32 CONF_GetPadDevices(conf_pads *pads);
s32 CONF_GetNickName(u8 *nickname);
s32 CONF_GetAspectRatio(void);
s32 CONF_GetEULA(void);
s32 CONF_GetParentalPassword(s8 *password);
s32 CONF_GetParentalAnswer(s8 *answer);
s32 CONF_GetWiiConnect24(void);
s32 CONF_GetRegion(void);
s32 CONF_GetArea(void);
s32 CONF_GetVideo(void);


   }
# 76 "d:/devkitPro/libogc/include/gccore.h" 2
# 1 "d:/devkitPro/libogc/include/ogc/usbstorage.h" 1






# 1 "d:/devkitPro/libogc/include/ogc/mutex.h" 1
# 8 "d:/devkitPro/libogc/include/ogc/usbstorage.h" 2

# 1 "d:/devkitPro/libogc/include/ogc/system.h" 1
# 10 "d:/devkitPro/libogc/include/ogc/usbstorage.h" 2


   extern "C" {
# 28 "d:/devkitPro/libogc/include/ogc/usbstorage.h"
typedef struct
{
 u8 configuration;
 u32 interface;
 u32 altInterface;
 u8 bInterfaceSubClass;

 u8 ep_in;
 u8 ep_out;

 u8 max_lun;
 u32 *sector_size;

 s32 usb_fd;

 mutex_t lock;
 syswd_t alarm;
 s32 retval;

 u32 tag;
 u8 suspended;

 u8 *buffer;
} usbstorage_handle;




typedef struct {
   uint8_t command[16];
   uint8_t command_length;
   uint8_t flags;
   uint8_t scsi_status;
   void* data;
   size_t data_length;
} raw_device_command;

s32 USBStorage_Initialize();

s32 USBStorage_Open(usbstorage_handle *dev, s32 device_id, u16 vid, u16 pid);
s32 USBStorage_Close(usbstorage_handle *dev);
s32 USBStorage_Reset(usbstorage_handle *dev);

s32 USBStorage_GetMaxLUN(usbstorage_handle *dev);
s32 USBStorage_MountLUN(usbstorage_handle *dev, u8 lun);
s32 USBStorage_Suspend(usbstorage_handle *dev);
s32 USBStorage_IsDVD();
s32 USBStorage_ioctl(int request, ...);

s32 USBStorage_ReadCapacity(usbstorage_handle *dev, u8 lun, u32 *sector_size, u32 *n_sectors);
s32 USBStorage_Read(usbstorage_handle *dev, u8 lun, u32 sector, u16 n_sectors, u8 *buffer);
s32 USBStorage_Write(usbstorage_handle *dev, u8 lun, u32 sector, u16 n_sectors, const u8 *buffer);
s32 USBStorage_StartStop(usbstorage_handle *dev, u8 lun, u8 lo_ej, u8 start, u8 imm);



extern DISC_INTERFACE __io_usbstorage;


   }
# 77 "d:/devkitPro/libogc/include/gccore.h" 2

# 1 "d:/devkitPro/libogc/include/ogc/wiilaunch.h" 1
# 62 "d:/devkitPro/libogc/include/ogc/wiilaunch.h"
   extern "C" {


s32 WII_Initialize(void);
s32 WII_ReturnToMenu(void);
s32 WII_ReturnToSettings(void);
s32 WII_ReturnToSettingsPage(const char *page);
s32 WII_LaunchTitle(u64 titleID);
s32 WII_LaunchTitleWithArgs(u64 titleID, int launchcode, ...);
s32 WII_OpenURL(const char *url);


   }
# 79 "d:/devkitPro/libogc/include/gccore.h" 2
# 99 "d:/devkitPro/libogc/include/gccore.h"
   extern "C" {
# 141 "d:/devkitPro/libogc/include/gccore.h"
s32 depackrnc1_ulen(void *packed);
s32 depackrnc1(void *packed,void *unpacked);

void depackrnc2(void *packed,void *unpacked);


   }
# 5 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/malloc.h" 1 3
# 10 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/malloc.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 11 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/malloc.h" 2 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/malloc.h" 1 3
# 14 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/malloc.h" 2 3


extern "C" {





struct mallinfo {
  int arena;
  int ordblks;
  int smblks;
  int hblks;
  int hblkhd;
  int usmblks;
  int fsmblks;
  int uordblks;
  int fordblks;
  int keepcost;
};



extern void * malloc (size_t);




extern void * _malloc_r (struct _reent *, size_t);


extern void free (void *);




extern void _free_r (struct _reent *, void *);


extern void * realloc (void *, size_t);




extern void * _realloc_r (struct _reent *, void *, size_t);


extern void * calloc (size_t, size_t);




extern void * _calloc_r (struct _reent *, size_t, size_t);


extern void * memalign (size_t, size_t);




extern void * _memalign_r (struct _reent *, size_t, size_t);


extern struct mallinfo mallinfo (void);




extern struct mallinfo _mallinfo_r (struct _reent *);


extern void malloc_stats (void);




extern void _malloc_stats_r (struct _reent *);


extern int mallopt (int, int);




extern int _mallopt_r (struct _reent *, int, int);


extern size_t malloc_usable_size (void *);




extern size_t _malloc_usable_size_r (struct _reent *, void *);





extern void * valloc (size_t);




extern void * _valloc_r (struct _reent *, size_t);


extern void * pvalloc (size_t);




extern void * _pvalloc_r (struct _reent *, size_t);


extern int malloc_trim (size_t);




extern int _malloc_trim_r (struct _reent *, size_t);




extern void mstats (char *);




extern void _mstats_r (struct _reent *, char *);
# 162 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/malloc.h" 3
extern void cfree (void *);



}
# 6 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 1 3
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 35 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 1 3 4
# 40 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 38 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3
# 48 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
extern "C" {

typedef __FILE FILE;




typedef _fpos_t fpos_t;





# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/stdio.h" 1 3
# 9 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/stdio.h" 3
     extern void __flockfile(FILE *fp);
# 18 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/stdio.h" 3
     extern void __funlockfile(FILE *fp);
# 62 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3
# 171 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
FILE * tmpfile (void);
char * tmpnam (char *);
int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *, const char *, FILE *);
void setbuf (FILE *, char *);
int setvbuf (FILE *, char *, int, size_t);
int fprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int printf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int scanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int sscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int vfprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int vsprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int fgetc (FILE *);
char * fgets (char *, int, FILE *);
int fputc (int, FILE *);
int fputs (const char *, FILE *);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *, size_t _size, size_t _n, FILE *);
size_t fwrite (const void * , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *, fpos_t *);

int fseek (FILE *, off_t, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *_name, const char *_type);
int sprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int remove (const char *);
int rename (const char *, const char *);






int fseeko (FILE *, off_t, int);
off_t ftello ( FILE *);




int asiprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
char * asniprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * asnprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int asprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int diprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int fcloseall (void);
int fiprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fiscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int iprintf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int iscanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int siprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int siscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int snprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int sniprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * tempnam (const char *, const char *);
int vasiprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
char * vasniprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * vasnprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vasprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vdiprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vfscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int viprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int viscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vsiprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vsiscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vsniprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsnprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
# 313 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
FILE * fdopen (int, const char *);

int fileno (FILE *);
int getw (FILE *);
int pclose (FILE *);
FILE * popen (const char *, const char *);
int putw (int, FILE *);
void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);
int getc_unlocked (FILE *);
int getchar_unlocked (void);
void flockfile (FILE *);
int ftrylockfile (FILE *);
void funlockfile (FILE *);
int putc_unlocked (int, FILE *);
int putchar_unlocked (int);
# 338 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
int dprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

FILE * fmemopen (void *, size_t, const char *);


FILE * open_memstream (char **, size_t *);



int vdprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;







int _asiprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
char * _asnprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _asprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _diprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _dprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
int _fgetc_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *, int, FILE *);




int _fgetpos_r (struct _reent *, FILE *, fpos_t *);
int _fsetpos_r (struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fiscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
FILE * _fmemopen_r (struct _reent *, void *, size_t, const char *);
FILE * _fopen_r (struct _reent *, const char *, const char *);
FILE * _freopen_r (struct _reent *, const char *, const char *, FILE *);
int _fprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fpurge_r (struct _reent *, FILE *);
int _fputc_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *, FILE *);
size_t _fread_r (struct _reent *, void *, size_t _size, size_t _n, FILE *);
int _fscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _fseek_r (struct _reent *, FILE *, off_t, int);
int _fseeko_r (struct _reent *, FILE *, _off_t, int);
long _ftell_r (struct _reent *, FILE *);
_off_t _ftello_r (struct _reent *, FILE *);
void _rewind_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void * , size_t _size, size_t _n, FILE *);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _iscanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *, const char *_old, const char *_new)
                                          ;
int _scanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int _siprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _siscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _snprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _sprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _sscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vfprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _vscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsnprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;



int fpurge (FILE *);
ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 515 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 535 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
FILE *funopen (const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))



                                   ;
FILE *_funopen_r (struct _reent *, const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))



                                   ;







typedef ssize_t cookie_read_function_t(void *__cookie, char *__buf, size_t __n);
typedef ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
     size_t __n);




typedef int cookie_seek_function_t(void *__cookie, off_t *__off, int __whence);

typedef int cookie_close_function_t(void *__cookie);
typedef struct
{


  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
FILE *fopencookie (void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
FILE *_fopencookie_r (struct _reent *, void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
# 683 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
}
# 7 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 1 3
# 15 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 16 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 2 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/stdlib.h" 1 3
# 19 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 2 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/alloca.h" 1 3
# 21 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 2 3






extern "C" {

typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;


typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;
# 58 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 3
int __locale_mb_cur_max (void);



void abort (void) __attribute__ ((noreturn));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);

float atoff (const char *__nptr);

int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, int (* _compar) (const void *, const void *))



                                                         ;
void * calloc (size_t __nmemb, size_t __size) __attribute__ ((nothrow));
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *) __attribute__ ((nothrow));
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);

extern char *suboptarg;
int getsubopt (char **, char * const *, char **);

long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) __attribute__ ((nothrow));
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *, const char *, size_t);
int _mbtowc_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *, const char *, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
size_t wcstombs (char *, const wchar_t *, size_t);
size_t _wcstombs_r (struct _reent *, char *, const wchar_t *, size_t, _mbstate_t *);


char * mkdtemp (char *);
int mkostemp (char *, int);
int mkostemps (char *, int, int);
int mkstemp (char *);
int mkstemps (char *, int);
char * mktemp (char *) __attribute__ ((__warning__ ("the use of `mktemp' is dangerous; use `mkstemp' instead")));

char * _mkdtemp_r (struct _reent *, char *);
int _mkostemp_r (struct _reent *, char *, int);
int _mkostemps_r (struct _reent *, char *, int, int);
int _mkstemp_r (struct _reent *, char *);
int _mkstemps_r (struct _reent *, char *, int);
char * _mktemp_r (struct _reent *, char *) __attribute__ ((__warning__ ("the use of `mktemp' is dangerous; use `mkstemp' instead")));

void qsort (void * __base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void *));
int rand (void);
void * realloc (void * __r, size_t __size) __attribute__ ((nothrow));

void * reallocf (void * __r, size_t __size);

void srand (unsigned __seed);
double strtod (const char *__n, char **__end_PTR);
double _strtod_r (struct _reent *,const char *__n, char **__end_PTR);
float strtof (const char *__n, char **__end_PTR);






long strtol (const char *__n, char **__end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__n, char **__end_PTR, int __base);
unsigned long strtoul (const char *__n, char **__end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__n, char **__end_PTR, int __base);

int system (const char *__string);


long a64l (const char *__input);
char * l64a (long __input);
char * _l64a_r (struct _reent *,long __input);
int on_exit (void (*__func)(int, void *),void * __arg);
void _Exit (int __status) __attribute__ ((noreturn));
int putenv (char *__string);
int _putenv_r (struct _reent *, char *__string);
void * _reallocf_r (struct _reent *, void *, size_t);
int setenv (const char *__string, const char *__value, int __overwrite);
int _setenv_r (struct _reent *, const char *__string, const char *__value, int __overwrite);

char * gcvt (double,int,char *);
char * gcvtf (float,int,char *);
char * fcvt (double,int,int *,int *);
char * fcvtf (float,int,int *,int *);
char * ecvt (double,int,int *,int *);
char * ecvtbuf (double, int, int*, int*, char *);
char * fcvtbuf (double, int, int*, int*, char *);
char * ecvtf (float,int,int *,int *);
char * dtoa (double, int, int, int *, int*, char**);
int rand_r (unsigned *__seed);

double drand48 (void);
double _drand48_r (struct _reent *);
double erand48 (unsigned short [3]);
double _erand48_r (struct _reent *, unsigned short [3]);
long jrand48 (unsigned short [3]);
long _jrand48_r (struct _reent *, unsigned short [3]);
void lcong48 (unsigned short [7]);
void _lcong48_r (struct _reent *, unsigned short [7]);
long lrand48 (void);
long _lrand48_r (struct _reent *);
long mrand48 (void);
long _mrand48_r (struct _reent *);
long nrand48 (unsigned short [3]);
long _nrand48_r (struct _reent *, unsigned short [3]);
unsigned short *
       seed48 (unsigned short [3]);
unsigned short *
       _seed48_r (struct _reent *, unsigned short [3]);
void srand48 (long);
void _srand48_r (struct _reent *, long);
long long atoll (const char *__nptr);
long long _atoll_r (struct _reent *, const char *__nptr);
long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *__n, char **__end_PTR, int __base);
long long _strtoll_r (struct _reent *, const char *__n, char **__end_PTR, int __base);
unsigned long long strtoull (const char *__n, char **__end_PTR, int __base);
unsigned long long _strtoull_r (struct _reent *, const char *__n, char **__end_PTR, int __base);


void cfree (void *);
int unsetenv (const char *__string);
int _unsetenv_r (struct _reent *, const char *__string);
# 206 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 3
char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) __attribute__ ((nothrow));
void * _calloc_r (struct _reent *, size_t, size_t) __attribute__ ((nothrow));
void _free_r (struct _reent *, void *) __attribute__ ((nothrow));
void * _realloc_r (struct _reent *, void *, size_t) __attribute__ ((nothrow));
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);



extern long double strtold (const char *, char **);
extern long double wcstold (const wchar_t *, wchar_t **);


}
# 8 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 1 3
# 12 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/cdefs.h" 1 3
# 13 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 2 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 16 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 2 3





extern "C" {

void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void *, const void *, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *, const char *);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *, const char *);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *, const char *, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *, const char *, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);


char *strtok (char *, const char *);


size_t strxfrm (char *, const char *, size_t);


char *strtok_r (char *, const char *, char **);

int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
int ffs (int);
char *index (const char *, int);
void * memccpy (void *, const void *, int, size_t);
void * mempcpy (void *, const void *, size_t);
void * memmem (const void *, size_t, const void *, size_t);
char *rindex (const char *, int);
char *stpcpy (char *, const char *);
char *stpncpy (char *, const char *, size_t);
int strcasecmp (const char *, const char *);
char *strcasestr (const char *, const char *);
char *strchrnul (const char *, int);
char *strdup (const char *);
char *_strdup_r (struct _reent *, const char *);
char *strndup (const char *, size_t);
char *_strndup_r (struct _reent *, const char *, size_t);
# 79 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 3
int strerror_r (int, char *, size_t) __asm__ ("" "__xpg_strerror_r");





size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
int strncasecmp (const char *, const char *, size_t);
size_t strnlen (const char *, size_t);
char *strsep (char **, const char *);
char *strlwr (char *);
char *strupr (char *);

char *strsignal (int __signo);






char * _strerror_r (struct _reent *, int, int, int *);
# 132 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/string.h" 1 3
# 133 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 2 3

}
# 9 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/unistd.h" 1 3



# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/unistd.h" 1 3




extern "C" {







# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 14 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/unistd.h" 2 3

extern char **environ;

void _exit (int __status ) __attribute__ ((noreturn));

int access (const char *__path, int __amode );
unsigned alarm (unsigned __secs );
int chdir (const char *__path );
int chmod (const char *__path, mode_t __mode );

int chown (const char *__path, uid_t __owner, gid_t __group );




int close (int __fildes );



char * ctermid (char *__s );
char * cuserid (char *__s );



int dup (int __fildes );
int dup2 (int __fildes, int __fildes2 );






int execl (const char *__path, const char *, ... );
int execle (const char *__path, const char *, ... );
int execlp (const char *__file, const char *, ... );



int execv (const char *__path, char * const __argv[] );
int execve (const char *__path, char * const __argv[], char * const __envp[] );
int execvp (const char *__file, char * const __argv[] );







int fchmod (int __fildes, mode_t __mode );

int fchown (int __fildes, uid_t __owner, gid_t __group );





pid_t fork (void );
long fpathconf (int __fd, int __name );
int fsync (int __fd);
int fdatasync (int __fd);
char * getcwd (char *__buf, size_t __size );




gid_t getegid (void );
uid_t geteuid (void );
gid_t getgid (void );

int getgroups (int __gidsetsize, gid_t __grouplist[] );



char * getlogin (void );



char * getpass (const char *__prompt);
int getpagesize (void);



pid_t getpgid (pid_t);
pid_t getpgrp (void );
pid_t getpid (void );
pid_t getppid (void );




uid_t getuid (void );






int isatty (int __fildes );

int lchown (const char *__path, uid_t __owner, gid_t __group );

int link (const char *__path1, const char *__path2 );



int nice (int __nice_value );

off_t lseek (int __fildes, off_t __offset, int __whence );
# 130 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/unistd.h" 3
long pathconf (const char *__path, int __name );
int pause (void );



int pipe (int __fildes[2] );



ssize_t pread (int __fd, void *__buf, size_t __nbytes, off_t __offset);
ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, off_t __offset);
int read (int __fd, void *__buf, size_t __nbyte );




int rmdir (const char *__path );



void * sbrk (ptrdiff_t __incr);





int setgid (gid_t __gid );




int setpgid (pid_t __pid, pid_t __pgid );
int setpgrp (void );




pid_t setsid (void );

int setuid (uid_t __uid );




unsigned sleep (unsigned int __seconds );
void swab (const void *, void *, ssize_t);
long sysconf (int __name );
pid_t tcgetpgrp (int __fildes );
int tcsetpgrp (int __fildes, pid_t __pgrp_id );
char * ttyname (int __fildes );



int unlink (const char *__path );
int usleep (useconds_t __useconds);
int vhangup (void );
int write (int __fd, const void *__buf, size_t __nbyte );






extern char *optarg;
extern int optind, opterr, optopt;
int getopt(int, char * const [], const char *);
extern int optreset;



pid_t vfork (void );
# 223 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/unistd.h" 3
int ftruncate (int __fd, off_t __length);
int truncate (const char *, off_t __length);
# 242 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/unistd.h" 3
ssize_t readlink (const char *__path, char *__buf, size_t __buflen);



int symlink (const char *__name1, const char *__name2);
# 503 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/unistd.h" 3
}
# 5 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/unistd.h" 2 3
# 10 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/wchar.h" 1 3
# 11 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/wchar.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 12 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/wchar.h" 2 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 1 3 4
# 15 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/wchar.h" 2 3
# 42 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/wchar.h" 3
extern "C" {



struct tm;



typedef _mbstate_t mbstate_t;


wint_t btowc (int);
int wctob (wint_t);
size_t mbrlen (const char * , size_t, mbstate_t *);
size_t mbrtowc (wchar_t * , const char * , size_t, mbstate_t *);
size_t _mbrtowc_r (struct _reent *, wchar_t * , const char * , size_t, mbstate_t *)
                        ;
int mbsinit (const mbstate_t *);
size_t mbsnrtowcs (wchar_t * , const char ** , size_t, size_t, mbstate_t *)
                ;
size_t _mbsnrtowcs_r (struct _reent *, wchar_t * , const char ** , size_t, size_t, mbstate_t *)
                                ;
size_t mbsrtowcs (wchar_t * , const char ** , size_t, mbstate_t *);
size_t _mbsrtowcs_r (struct _reent *, wchar_t * , const char ** , size_t, mbstate_t *);
size_t wcrtomb (char * , wchar_t, mbstate_t *);
size_t _wcrtomb_r (struct _reent *, char * , wchar_t, mbstate_t *);
size_t wcsnrtombs (char * , const wchar_t ** , size_t, size_t, mbstate_t *)
                ;
size_t _wcsnrtombs_r (struct _reent *, char * , const wchar_t ** , size_t, size_t, mbstate_t *)
                                ;
size_t wcsrtombs (char * , const wchar_t ** , size_t, mbstate_t *);
size_t _wcsrtombs_r (struct _reent *, char * , const wchar_t ** , size_t, mbstate_t *)
                        ;
int wcscasecmp (const wchar_t *, const wchar_t *);
wchar_t *wcscat (wchar_t * , const wchar_t *);
wchar_t *wcschr (const wchar_t *, wchar_t);
int wcscmp (const wchar_t *, const wchar_t *);
int wcscoll (const wchar_t *, const wchar_t *);
wchar_t *wcscpy (wchar_t * , const wchar_t *);
wchar_t *wcpcpy (wchar_t * , const wchar_t *);
wchar_t *wcsdup (const wchar_t *);
wchar_t *_wcsdup_r (struct _reent *, const wchar_t * );
size_t wcscspn (const wchar_t *, const wchar_t *);
size_t wcsftime (wchar_t *, size_t, const wchar_t *, const struct tm *);
size_t wcslcat (wchar_t *, const wchar_t *, size_t);
size_t wcslcpy (wchar_t *, const wchar_t *, size_t);
size_t wcslen (const wchar_t *);
int wcsncasecmp (const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncat (wchar_t * , const wchar_t * , size_t);
int wcsncmp (const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy (wchar_t * , const wchar_t * , size_t);
wchar_t *wcpncpy (wchar_t * , const wchar_t * , size_t);
size_t wcsnlen (const wchar_t *, size_t);
wchar_t *wcspbrk (const wchar_t *, const wchar_t *);
wchar_t *wcsrchr (const wchar_t *, wchar_t);
size_t wcsspn (const wchar_t *, const wchar_t *);
wchar_t *wcsstr (const wchar_t *, const wchar_t *);
wchar_t *wcstok (wchar_t *, const wchar_t *, wchar_t **);
double wcstod (const wchar_t *, wchar_t **);
double _wcstod_r (struct _reent *, const wchar_t *, wchar_t **);
float wcstof (const wchar_t *, wchar_t **);
float _wcstof_r (struct _reent *, const wchar_t *, wchar_t **);
int wcswidth (const wchar_t *, size_t);
size_t wcsxfrm (wchar_t *, const wchar_t *, size_t);
int wcwidth (const wchar_t);
wchar_t *wmemchr (const wchar_t *, wchar_t, size_t);
int wmemcmp (const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy (wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove (wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset (wchar_t *, wchar_t, size_t);

long wcstol (const wchar_t *, wchar_t **, int);
long long wcstoll (const wchar_t *, wchar_t **, int);
unsigned long wcstoul (const wchar_t *, wchar_t **, int);
unsigned long long wcstoull (const wchar_t *, wchar_t **, int);
long _wcstol_r (struct _reent *, const wchar_t *, wchar_t **, int);
long long _wcstoll_r (struct _reent *, const wchar_t *, wchar_t **, int);
unsigned long _wcstoul_r (struct _reent *, const wchar_t *, wchar_t **, int);
unsigned long long _wcstoull_r (struct _reent *, const wchar_t *, wchar_t **, int);

wint_t fgetwc (__FILE *);
wchar_t *fgetws (wchar_t *, int, __FILE *);
wint_t fputwc (wchar_t, __FILE *);
int fputws (const wchar_t *, __FILE *);
int fwide (__FILE *, int);
wint_t getwc (__FILE *);
wint_t getwchar (void);
wint_t putwc (wchar_t, __FILE *);
wint_t putwchar (wchar_t);
wint_t ungetwc (wint_t wc, __FILE *);

wint_t _fgetwc_r (struct _reent *, __FILE *);
wchar_t *_fgetws_r (struct _reent *, wchar_t *, int, __FILE *);
wint_t _fputwc_r (struct _reent *, wchar_t, __FILE *);
int _fputws_r (struct _reent *, const wchar_t *, __FILE *);
int _fwide_r (struct _reent *, __FILE *, int);
wint_t _getwc_r (struct _reent *, __FILE *);
wint_t _getwchar_r (struct _reent *ptr);
wint_t _putwc_r (struct _reent *, wchar_t, __FILE *);
wint_t _putwchar_r (struct _reent *, wchar_t);
wint_t _ungetwc_r (struct _reent *, wint_t wc, __FILE *);

__FILE *open_wmemstream (wchar_t **, size_t *);
__FILE *_open_wmemstream_r (struct _reent *, wchar_t **, size_t *);
# 155 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/wchar.h" 3
int fwprintf (__FILE *, const wchar_t *, ...);
int swprintf (wchar_t *, size_t, const wchar_t *, ...);
int vfwprintf (__FILE *, const wchar_t *, __gnuc_va_list);
int vswprintf (wchar_t *, size_t, const wchar_t *, __gnuc_va_list);
int vwprintf (const wchar_t *, __gnuc_va_list);
int wprintf (const wchar_t *, ...);

int _fwprintf_r (struct _reent *, __FILE *, const wchar_t *, ...);
int _swprintf_r (struct _reent *, wchar_t *, size_t, const wchar_t *, ...);
int _vfwprintf_r (struct _reent *, __FILE *, const wchar_t *, __gnuc_va_list);
int _vswprintf_r (struct _reent *, wchar_t *, size_t, const wchar_t *, __gnuc_va_list);
int _vwprintf_r (struct _reent *, const wchar_t *, __gnuc_va_list);
int _wprintf_r (struct _reent *, const wchar_t *, ...);

int fwscanf (__FILE *, const wchar_t *, ...);
int swscanf (const wchar_t *, const wchar_t *, ...);
int vfwscanf (__FILE *, const wchar_t *, __gnuc_va_list);
int vswscanf (const wchar_t *, const wchar_t *, __gnuc_va_list);
int vwscanf (const wchar_t *, __gnuc_va_list);
int wscanf (const wchar_t *, ...);

int _fwscanf_r (struct _reent *, __FILE *, const wchar_t *, ...);
int _swscanf_r (struct _reent *, const wchar_t *, const wchar_t *, ...);
int _vfwscanf_r (struct _reent *, __FILE *, const wchar_t *, __gnuc_va_list);
int _vswscanf_r (struct _reent *, const wchar_t *, const wchar_t *, __gnuc_va_list);
int _vwscanf_r (struct _reent *, const wchar_t *, __gnuc_va_list);
int _wscanf_r (struct _reent *, const wchar_t *, ...);
# 193 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/wchar.h" 3
}
# 11 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 1 3
# 9 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern "C" {




union __dmath
{
  double d;
  __ULong i[2];
};

union __fmath
{
  float f;
  __ULong i[1];
};


union __ldmath
{
  long double ld;
  __ULong i[4];
};
# 111 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern double atan (double);
extern double cos (double);
extern double sin (double);
extern double tan (double);
extern double tanh (double);
extern double frexp (double, int *);
extern double modf (double, double *);
extern double ceil (double);
extern double fabs (double);
extern double floor (double);






extern double acos (double);
extern double asin (double);
extern double atan2 (double, double);
extern double cosh (double);
extern double sinh (double);
extern double exp (double);
extern double ldexp (double, int);
extern double log (double);
extern double log10 (double);
extern double pow (double, double);
extern double sqrt (double);
extern double fmod (double, double);
# 148 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
typedef float float_t;
typedef double double_t;
# 175 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern int __isinff (float x);
extern int __isinfd (double x);
extern int __isnanf (float x);
extern int __isnand (double x);
extern int __fpclassifyf (float x);
extern int __fpclassifyd (double x);
extern int __signbitf (float x);
extern int __signbitd (double x);
# 235 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern double infinity (void);
extern double nan (const char *);
extern int finite (double);
extern double copysign (double, double);
extern double logb (double);
extern int ilogb (double);

extern double asinh (double);
extern double cbrt (double);
extern double nextafter (double, double);
extern double rint (double);
extern double scalbn (double, int);

extern double exp2 (double);
extern double scalbln (double, long int);
extern double tgamma (double);
extern double nearbyint (double);
extern long int lrint (double);
extern long long int llrint (double);
extern double round (double);
extern long int lround (double);
extern long long int llround (double);
extern double trunc (double);
extern double remquo (double, double, int *);
extern double fdim (double, double);
extern double fmax (double, double);
extern double fmin (double, double);
extern double fma (double, double, double);


extern double log1p (double);
extern double expm1 (double);



extern double acosh (double);
extern double atanh (double);
extern double remainder (double, double);
extern double gamma (double);
extern double lgamma (double);
extern double erf (double);
extern double erfc (double);
extern double log2 (double);





extern double hypot (double, double);






extern float atanf (float);
extern float cosf (float);
extern float sinf (float);
extern float tanf (float);
extern float tanhf (float);
extern float frexpf (float, int *);
extern float modff (float, float *);
extern float ceilf (float);
extern float fabsf (float);
extern float floorf (float);


extern float acosf (float);
extern float asinf (float);
extern float atan2f (float, float);
extern float coshf (float);
extern float sinhf (float);
extern float expf (float);
extern float ldexpf (float, int);
extern float logf (float);
extern float log10f (float);
extern float powf (float, float);
extern float sqrtf (float);
extern float fmodf (float, float);




extern float exp2f (float);
extern float scalblnf (float, long int);
extern float tgammaf (float);
extern float nearbyintf (float);
extern long int lrintf (float);
extern long long llrintf (float);
extern float roundf (float);
extern long int lroundf (float);
extern long long int llroundf (float);
extern float truncf (float);
extern float remquof (float, float, int *);
extern float fdimf (float, float);
extern float fmaxf (float, float);
extern float fminf (float, float);
extern float fmaf (float, float, float);

extern float infinityf (void);
extern float nanf (const char *);
extern int finitef (float);
extern float copysignf (float, float);
extern float logbf (float);
extern int ilogbf (float);

extern float asinhf (float);
extern float cbrtf (float);
extern float nextafterf (float, float);
extern float rintf (float);
extern float scalbnf (float, int);
extern float log1pf (float);
extern float expm1f (float);


extern float acoshf (float);
extern float atanhf (float);
extern float remainderf (float, float);
extern float gammaf (float);
extern float lgammaf (float);
extern float erff (float);
extern float erfcf (float);
extern float log2f (float);



extern float hypotf (float, float);






extern long double atanl (long double);
extern long double cosl (long double);
extern long double sinl (long double);
extern long double tanl (long double);
extern long double tanhl (long double);
extern long double frexpl (long double value, int *);
extern long double modfl (long double, long double *);
extern long double ceill (long double);
extern long double fabsl (long double);
extern long double floorl (long double);
extern long double log1pl (long double);
extern long double expm1l (long double);




extern long double acosl (long double);
extern long double asinl (long double);
extern long double atan2l (long double, long double);
extern long double coshl (long double);
extern long double sinhl (long double);
extern long double expl (long double);
extern long double ldexpl (long double, int);
extern long double logl (long double);
extern long double log10l (long double);
extern long double powl (long double, long double);
extern long double sqrtl (long double);
extern long double fmodl (long double, long double);
extern long double hypotl (long double, long double);


extern long double copysignl (long double, long double);
extern long double nanl (const char *);
extern int ilogbl (long double);
extern long double asinhl (long double);
extern long double cbrtl (long double);
extern long double nextafterl (long double, long double);
extern long double rintl (long double);
extern long double scalbnl (long double, int);
extern long double exp2l (long double);
extern long double scalblnl (long double, long);
extern long double tgammal (long double);
extern long double nearbyintl (long double);
extern long int lrintl (long double);
extern long long int llrintl (long double);
extern long double roundl (long double);
extern long lroundl (long double);
extern long long int llroundl (long double);
extern long double truncl (long double);
extern long double remquol (long double, long double, int *);
extern long double fdiml (long double, long double);
extern long double fmaxl (long double, long double);
extern long double fminl (long double, long double);
extern long double fmal (long double, long double, long double);

extern long double acoshl (long double);
extern long double atanhl (long double);
extern long double remainderl (long double, long double);
extern long double lgammal (long double);
extern long double erfl (long double);
extern long double erfcl (long double);
# 443 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern double drem (double, double);
extern void sincos (double, double *, double *);
extern double gamma_r (double, int *);
extern double lgamma_r (double, int *);

extern double y0 (double);
extern double y1 (double);
extern double yn (int, double);
extern double j0 (double);
extern double j1 (double);
extern double jn (int, double);

extern float dremf (float, float);
extern void sincosf (float, float *, float *);
extern float gammaf_r (float, int *);
extern float lgammaf_r (float, int *);

extern float y0f (float);
extern float y1f (float);
extern float ynf (int, float);
extern float j0f (float);
extern float j1f (float);
extern float jnf (int, float);



extern double exp10 (double);


extern double pow10 (double);


extern float exp10f (float);


extern float pow10f (float);
# 488 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern int *__signgam (void);
# 497 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
struct __exception



{
  int type;
  char *name;
  double arg1;
  double arg2;
  double retval;
  int err;
};


extern int matherr (struct __exception *e);
# 554 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
enum __fdlibm_version
{
  __fdlibm_ieee = -1,
  __fdlibm_svid,
  __fdlibm_xopen,
  __fdlibm_posix
};




extern enum __fdlibm_version __fdlib_version;
# 574 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
}
# 12 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:/devkitPro/libogc/include/wiiuse/wpad.h" 1
# 35 "d:/devkitPro/libogc/include/wiiuse/wpad.h"
# 1 "d:/devkitPro/libogc/include/wiiuse/wiiuse.h" 1
# 9 "d:/devkitPro/libogc/include/wiiuse/wiiuse.h"
# 1 "d:/devkitPro/libogc/include/bte/bte.h" 1




# 1 "d:/devkitPro/libogc/include/bte/bd_addr.h" 1
# 39 "d:/devkitPro/libogc/include/bte/bd_addr.h"
   extern "C" {


struct bd_addr {
  u8 addr[6];
};
# 76 "d:/devkitPro/libogc/include/bte/bd_addr.h"
   }
# 6 "d:/devkitPro/libogc/include/bte/bte.h" 2
# 70 "d:/devkitPro/libogc/include/bte/bte.h"
   extern "C" {


struct l2cap_pcb;
struct ctrl_req_t;

struct inquiry_info
{
 struct bd_addr bdaddr;
 u8 cod[3];
};

struct inquiry_info_ex
{
 struct bd_addr bdaddr;
 u8 cod[3];
 u8 psrm;
 u8 psm;
 u16 co;
};

struct linkkey_info
{
 struct bd_addr bdaddr;
 u8 key[16];
};

struct bte_pcb
{
 u8 err;
 u32 state;
 void *cbarg;

 struct ctrl_req_t *ctrl_req_head;
 struct ctrl_req_t *ctrl_req_tail;

 lwpq_t cmdq;

 struct bd_addr bdaddr;

 struct l2cap_pcb *ctl_pcb;
 struct l2cap_pcb *data_pcb;


 s32 (*recv)(void *arg,void *buffer,u16 len);
 s32 (*conn_cfm)(void *arg,struct bte_pcb *pcb,u8 err);
 s32 (*disconn_cfm)(void *arg,struct bte_pcb *pcb,u8 err);
};

typedef s32 (*btecallback)(s32 result,void *userdata);

void BTE_Init();
void BTE_Shutdown();
s32 BTE_InitCore(btecallback cb);
s32 BTE_ApplyPatch(btecallback cb);
s32 BTE_InitSub(btecallback cb);
s32 BTE_ReadStoredLinkKey(struct linkkey_info *keys,u8 max_cnt,btecallback cb);
void (*BTE_SetDisconnectCallback(void (*callback)(struct bd_addr *bdaddr,u8 reason)))(struct bd_addr *bdaddr,u8 reason);

struct bte_pcb* bte_new();
void bte_arg(struct bte_pcb *pcb,void *arg);
void bte_received(struct bte_pcb *pcb, s32 (*recv)(void *arg,void *buffer,u16 len));
void bte_disconnected(struct bte_pcb *pcb,s32 (disconn_cfm)(void *arg,struct bte_pcb *pcb,u8 err));

s32 bte_registerdeviceasync(struct bte_pcb *pcb,struct bd_addr *bdaddr,s32 (*conn_cfm)(void *arg,struct bte_pcb *pcb,u8 err));

s32 bte_disconnect(struct bte_pcb *pcb);



s32 bte_inquiry(struct inquiry_info *info,u8 max_cnt,u8 flush);
s32 bte_inquiry_ex(struct inquiry_info_ex *info,u8 max_cnt,u8 flush);


s32 bte_senddata(struct bte_pcb *pcb,void *message,u16 len);
s32 bte_sendmessage(struct bte_pcb *pcb,void *message,u16 len);
s32 bte_sendmessageasync(struct bte_pcb *pcb,void *message,u16 len,s32 (*sent)(void *arg,struct bte_pcb *pcb,u8 err));


   }
# 10 "d:/devkitPro/libogc/include/wiiuse/wiiuse.h" 2
# 109 "d:/devkitPro/libogc/include/wiiuse/wiiuse.h"
typedef enum ir_position_t {
 WIIUSE_IR_ABOVE,
 WIIUSE_IR_BELOW
} ir_position_t;
# 187 "d:/devkitPro/libogc/include/wiiuse/wiiuse.h"
typedef unsigned char ubyte;
typedef char sbyte;
typedef unsigned short uword;
typedef short sword;
typedef unsigned int uint;
typedef char sint;


struct wiimote_t;
struct vec3b_t;
struct orient_t;
struct gforce_t;


 typedef void (*wii_event_cb)(struct wiimote_t*, int event);
# 217 "d:/devkitPro/libogc/include/wiiuse/wiiuse.h"
typedef void (*wiiuse_data_cb)(struct wiimote_t* wm, ubyte* data, unsigned short len);

typedef enum data_req_s
{
 REQ_READY = 0,
 REQ_SENT,
 REQ_DONE
} data_req_s;





struct data_req_t {
 lwp_node node;
 ubyte data[48];
 unsigned int len;
 data_req_s state;
 wiiuse_data_cb cb;
 struct data_req_t *next;
};

typedef void (*cmd_blk_cb)(struct wiimote_t *wm,ubyte *data,uword len);

typedef enum cmd_blk_s
{
 CMD_READY = 0,
 CMD_SENT,
 CMD_DONE
} cmd_blk_s;

struct cmd_blk_t
{
 lwp_node node;

 ubyte data[48];
 uint len;

 cmd_blk_s state;
 cmd_blk_cb cb;

 struct cmd_blk_t *next;
};






typedef struct vec2b_t {
 ubyte x, y;
} vec2b_t;






typedef struct vec3b_t {
 ubyte x, y, z;
} vec3b_t;





typedef struct vec3w_t {
 uword x, y, z;
} vec3w_t;






typedef struct vec3f_t {
 float x, y, z;
} vec3f_t;
# 303 "d:/devkitPro/libogc/include/wiiuse/wiiuse.h"
typedef struct orient_t {
 float roll;
 float pitch;
 float yaw;

 float a_roll;
 float a_pitch;
} orient_t;






typedef struct gforce_t {
 float x, y, z;
} gforce_t;






typedef struct accel_t {
 struct vec3w_t cal_zero;
 struct vec3w_t cal_g;

 float st_roll;
 float st_pitch;
 float st_alpha;
} accel_t;






typedef struct ir_dot_t {
 ubyte visible;

 short rx;
 short ry;

 ubyte size;
} ir_dot_t;


typedef struct fdot_t {
 float x,y;
} fdot_t;

typedef struct sb_t {
 fdot_t dots[2];
 fdot_t acc_dots[2];
 fdot_t rot_dots[2];
 float angle;
 float off_angle;
 float score;
} sb_t;





typedef enum aspect_t {
 WIIUSE_ASPECT_4_3,
 WIIUSE_ASPECT_16_9
} aspect_t;






typedef struct ir_t {
 struct ir_dot_t dot[4];
 ubyte num_dots;

 int state;

 int raw_valid;
 sb_t sensorbar;
 float ax;
 float ay;
 float distance;
 float z;
 float angle;

 int smooth_valid;
 float sx;
 float sy;
 float error_cnt;
 float glitch_cnt;

 int valid;
 float x;
 float y;
 enum aspect_t aspect;
 enum ir_position_t pos;
 unsigned int vres[2];
 int offset[2];

} ir_t;
# 423 "d:/devkitPro/libogc/include/wiiuse/wiiuse.h"
typedef struct joystick_t {
 struct vec2b_t max;
 struct vec2b_t min;
 struct vec2b_t center;
 struct vec2b_t pos;

 float ang;
 float mag;
} joystick_t;






typedef struct nunchuk_t {
 struct accel_t accel_calib;
 struct joystick_t js;

 int* flags;

 ubyte btns;
 ubyte btns_last;
 ubyte btns_held;
 ubyte btns_released;

 struct vec3w_t accel;
 struct orient_t orient;
 struct gforce_t gforce;
} nunchuk_t;






typedef struct classic_ctrl_t {
 short btns;
 short btns_last;
 short btns_held;
 short btns_released;

 ubyte rs_raw;
 ubyte ls_raw;

 float r_shoulder;
 float l_shoulder;

 struct joystick_t ljs;
 struct joystick_t rjs;
} classic_ctrl_t;






typedef struct guitar_hero_3_t {
 short btns;
 short btns_last;
 short btns_held;
 short btns_released;

 ubyte wb_raw;
 float whammy_bar;

 ubyte tb_raw;
 int touch_bar;

 struct joystick_t js;
} guitar_hero_3_t;





typedef struct wii_board_t {
 float tl;
 float tr;
 float bl;
 float br;
 short rtl;
 short rtr;
 short rbl;
 short rbr;
 short ctl[3];
 short ctr[3];
 short cbl[3];
 short cbr[3];
 float x;
 float y;
} wii_board_t;

typedef struct motion_plus_t
{
 short rx, ry, rz;
 ubyte status;
 ubyte ext;
} motion_plus_t;





typedef struct expansion_t {
 int type;

 union {
  struct nunchuk_t nunchuk;
  struct classic_ctrl_t classic;
  struct guitar_hero_3_t gh3;
   struct wii_board_t wb;
  struct motion_plus_t mp;
 };
} expansion_t;






typedef enum win_bt_stack_t {
 WIIUSE_STACK_UNKNOWN,
 WIIUSE_STACK_MS,
 WIIUSE_STACK_BLUESOLEIL
} win_bt_stack_t;






typedef struct wiimote_state_t {
 unsigned short btns;

 struct ir_t ir;
 struct vec3w_t accel;
 struct expansion_t exp;
} wiimote_state_t;






typedef enum WIIUSE_EVENT_TYPE {
 WIIUSE_NONE = 0,
 WIIUSE_EVENT,
 WIIUSE_STATUS,
 WIIUSE_CONNECT,
 WIIUSE_DISCONNECT,
 WIIUSE_UNEXPECTED_DISCONNECT,
 WIIUSE_READ_DATA,
 WIIUSE_ACK,
 WIIUSE_NUNCHUK_INSERTED,
 WIIUSE_NUNCHUK_REMOVED,
 WIIUSE_CLASSIC_CTRL_INSERTED,
 WIIUSE_CLASSIC_CTRL_REMOVED,
 WIIUSE_GUITAR_HERO_3_CTRL_INSERTED,
  WIIUSE_GUITAR_HERO_3_CTRL_REMOVED,
  WIIUSE_WII_BOARD_INSERTED,
  WIIUSE_WII_BOARD_REMOVED,
  WIIUSE_MOTION_PLUS_ACTIVATED,
  WIIUSE_MOTION_PLUS_REMOVED
} WIIUSE_EVENT_TYPE;





typedef struct wiimote_t {
 const int unid;
# 604 "d:/devkitPro/libogc/include/wiiuse/wiiuse.h"
  const lwp_queue cmdq;
  const struct bd_addr bdaddr;
  const char bdaddr_str[18];
  const struct bte_pcb *sock;
  const wii_event_cb event_cb;







 const int state;
 const ubyte leds;

 const ubyte battery_level;




 const int flags;

 const ubyte handshake_state;
 const ubyte expansion_state;

 const struct data_req_t* data_req;

 const struct cmd_blk_t *cmd_head;
 const struct cmd_blk_t *cmd_tail;

 const struct accel_t accel_calib;
 const struct expansion_t exp;

 const struct vec3w_t accel;
 const struct orient_t orient;
 const struct gforce_t gforce;

 const struct ir_t ir;

 const unsigned short btns;
 const unsigned short btns_last;
 const unsigned short btns_held;
 const unsigned short btns_released;

 const struct wiimote_state_t lstate;

 const WIIUSE_EVENT_TYPE event;
 const ubyte event_buf[32];

 const ubyte motion_plus_id[6];
} wiimote;






typedef struct wiimote_listen_t {
 const struct bd_addr bdaddr;
 const struct bte_pcb *sock;
 const struct wiimote_t *(*assign_cb)(struct bd_addr *bdaddr);
 const struct wiimote_t *wm;
} wiimote_listen;
# 690 "d:/devkitPro/libogc/include/wiiuse/wiiuse.h"
extern "C" {



 extern const char* wiiuse_version();




 extern int wiiuse_register(struct wiimote_listen_t *wml, struct bd_addr *bdaddr, struct wiimote_t *(*assign_cb)(struct bd_addr *bdaddr));
 extern struct wiimote_t** wiiuse_init(int wiimotes, wii_event_cb event_cb);
 extern void wiiuse_sensorbar_enable(int enable);


 extern void wiiuse_disconnected(struct wiimote_t* wm);
 extern void wiiuse_cleanup(struct wiimote_t** wm, int wiimotes);
 extern void wiiuse_rumble(struct wiimote_t* wm, int status);
 extern void wiiuse_toggle_rumble(struct wiimote_t* wm);
 extern void wiiuse_set_leds(struct wiimote_t* wm, int leds,cmd_blk_cb cb);
 extern void wiiuse_motion_sensing(struct wiimote_t* wm, int status);
 extern int wiiuse_read_data(struct wiimote_t* wm, ubyte* buffer, unsigned int offset, unsigned short len, cmd_blk_cb cb);
 extern int wiiuse_write_data(struct wiimote_t *wm,unsigned int addr,ubyte *data,ubyte len,cmd_blk_cb cb);
 extern void wiiuse_status(struct wiimote_t *wm,cmd_blk_cb cb);
 extern struct wiimote_t* wiiuse_get_by_id(struct wiimote_t** wm, int wiimotes, int unid);
 extern int wiiuse_set_flags(struct wiimote_t* wm, int enable, int disable);
 extern float wiiuse_set_smooth_alpha(struct wiimote_t* wm, float alpha);
 extern void wiiuse_set_bluetooth_stack(struct wiimote_t** wm, int wiimotes, enum win_bt_stack_t type);
 extern void wiiuse_resync(struct wiimote_t* wm);
 extern void wiiuse_set_timeout(struct wiimote_t** wm, int wiimotes, ubyte normal_timeout, ubyte exp_timeout);
 extern int wiiuse_write_streamdata(struct wiimote_t *wm,ubyte *data,ubyte len,cmd_blk_cb cb);


 extern int wiiuse_find(struct wiimote_t** wm, int max_wiimotes, int timeout);
 extern int wiiuse_connect(struct wiimote_t** wm, int wiimotes);
 extern void wiiuse_disconnect(struct wiimote_t* wm);


 extern int wiiuse_poll(struct wiimote_t** wm, int wiimotes);


 extern void wiiuse_set_ir_mode(struct wiimote_t *wm);
 extern void wiiuse_set_ir(struct wiimote_t* wm, int status);
 extern void wiiuse_set_ir_vres(struct wiimote_t* wm, unsigned int x, unsigned int y);
 extern void wiiuse_set_ir_position(struct wiimote_t* wm, enum ir_position_t pos);
 extern void wiiuse_set_aspect_ratio(struct wiimote_t* wm, enum aspect_t aspect);
 extern void wiiuse_set_ir_sensitivity(struct wiimote_t* wm, int level);


 extern void wiiuse_set_motion_plus(struct wiimote_t *wm, int status);


 extern void wiiuse_set_speaker(struct wiimote_t *wm, int status);


}
# 36 "d:/devkitPro/libogc/include/wiiuse/wpad.h" 2



enum {
 WPAD_CHAN_ALL = -1,
 WPAD_CHAN_0,
 WPAD_CHAN_1,
 WPAD_CHAN_2,
 WPAD_CHAN_3,
 WPAD_BALANCE_BOARD,
 WPAD_MAX_WIIMOTES,
};
# 90 "d:/devkitPro/libogc/include/wiiuse/wpad.h"
enum {
 WPAD_EXP_NONE = 0,
 WPAD_EXP_NUNCHUK,
 WPAD_EXP_CLASSIC,
 WPAD_EXP_GUITARHERO3,
  WPAD_EXP_WIIBOARD,
 WPAD_EXP_UNKNOWN = 255
};

enum {
 WPAD_FMT_BTNS = 0,
 WPAD_FMT_BTNS_ACC,
 WPAD_FMT_BTNS_ACC_IR
};

enum {
 WPAD_STATE_DISABLED,
 WPAD_STATE_ENABLING,
 WPAD_STATE_ENABLED
};
# 140 "d:/devkitPro/libogc/include/wiiuse/wpad.h"
   extern "C" {


typedef struct _wpad_data
{
 s16 err;

 u32 data_present;
 u8 battery_level;

 u32 btns_h;
 u32 btns_l;
 u32 btns_d;
 u32 btns_u;

 struct ir_t ir;
 struct vec3w_t accel;
 struct orient_t orient;
 struct gforce_t gforce;
 struct expansion_t exp;
} WPADData;

typedef struct _wpad_encstatus
{
 u8 data[32];
}WPADEncStatus;

typedef void (*WPADDataCallback)(s32 chan, const WPADData *data);
typedef void (*WPADShutdownCallback)(s32 chan);

s32 WPAD_Init();
s32 WPAD_ControlSpeaker(s32 chan,s32 enable);
s32 WPAD_ReadEvent(s32 chan, WPADData *data);
s32 WPAD_DroppedEvents(s32 chan);
s32 WPAD_Flush(s32 chan);
s32 WPAD_ReadPending(s32 chan, WPADDataCallback datacb);
s32 WPAD_SetDataFormat(s32 chan, s32 fmt);
s32 WPAD_SetMotionPlus(s32 chan, u8 enable);
s32 WPAD_SetVRes(s32 chan,u32 xres,u32 yres);
s32 WPAD_GetStatus();
s32 WPAD_Probe(s32 chan,u32 *type);
s32 WPAD_SetEventBufs(s32 chan, WPADData *bufs, u32 cnt);
s32 WPAD_Disconnect(s32 chan);
s32 WPAD_IsSpeakerEnabled(s32 chan);
s32 WPAD_SendStreamData(s32 chan,void *buf,u32 len);
void WPAD_Shutdown();
void WPAD_SetIdleTimeout(u32 seconds);
void WPAD_SetPowerButtonCallback(WPADShutdownCallback cb);
void WPAD_SetBatteryDeadCallback(WPADShutdownCallback cb);
s32 WPAD_ScanPads();
s32 WPAD_Rumble(s32 chan, int status);
s32 WPAD_SetIdleThresholds(s32 chan, s32 btns, s32 ir, s32 accel, s32 js, s32 wb, s32 mp);
void WPAD_EncodeData(WPADEncStatus *info,u32 flag,const s16 *pcmSamples,s32 numSamples,u8 *encData);
WPADData *WPAD_Data(int chan);
u8 WPAD_BatteryLevel(int chan);
u32 WPAD_ButtonsUp(int chan);
u32 WPAD_ButtonsDown(int chan);
u32 WPAD_ButtonsHeld(int chan);
void WPAD_IR(int chan, struct ir_t *ir);
void WPAD_Orientation(int chan, struct orient_t *orient);
void WPAD_GForce(int chan, struct gforce_t *gforce);
void WPAD_Accel(int chan, struct vec3w_t *accel);
void WPAD_Expansion(int chan, struct expansion_t *exp);


   }
# 13 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:/devkitPro/libogc/include/gd.h" 1

extern "C" {
# 60 "d:/devkitPro/libogc/include/gd.h"
extern "C"
{
# 93 "d:/devkitPro/libogc/include/gd.h"
# 1 "d:/devkitPro/libogc/include/gd_io.h" 1

extern "C" {
# 14 "d:/devkitPro/libogc/include/gd_io.h"
typedef struct gdIOCtx
{
 int (*getC)(struct gdIOCtx *);
 int (*getBuf)(struct gdIOCtx *, void *, int);
 void (*putC)(struct gdIOCtx *, int);
 int (*putBuf)(struct gdIOCtx *, const void *, int);

 int (*seek)(struct gdIOCtx *, const int);
 long (*tell)(struct gdIOCtx *);
 void (*gd_free)(struct gdIOCtx *);
}
gdIOCtx;

typedef struct gdIOCtx *gdIOCtxPtr;

void Putword(int w, gdIOCtx *ctx);
void Putchar(int c, gdIOCtx *ctx);

void gdPutC(const unsigned char c, gdIOCtx *ctx);
int gdPutBuf(const void *, int, gdIOCtx *);
void gdPutWord(int w, gdIOCtx *ctx);
void gdPutInt(int w, gdIOCtx *ctx);

int gdGetC(gdIOCtx *ctx);
int gdGetBuf(void *, int, gdIOCtx *);
int gdGetByte(int *result, gdIOCtx *ctx);
int gdGetWord(int *result, gdIOCtx *ctx);
int gdGetWordLSB(signed short int *result, gdIOCtx *ctx);
int gdGetInt(int *result, gdIOCtx *ctx);
int gdGetIntLSB(signed int *result, gdIOCtx *ctx);

int gdSeek(gdIOCtx *ctx, const int offset);
long gdTell(gdIOCtx *ctx);




}
# 94 "d:/devkitPro/libogc/include/gd.h" 2
# 133 "d:/devkitPro/libogc/include/gd.h"
enum gdCropMode {
 GD_CROP_DEFAULT = 0,
 GD_CROP_TRANSPARENT,
 GD_CROP_BLACK,
 GD_CROP_WHITE,
 GD_CROP_SIDES
};







extern int gdAlphaBlend (int dest, int src);

  typedef struct gdImageStruct
  {

    unsigned char **pixels;
    int sx;
    int sy;



    int colorsTotal;
    int red[256];
    int green[256];
    int blue[256];
    int open[256];
# 173 "d:/devkitPro/libogc/include/gd.h"
    int transparent;
    int *polyInts;
    int polyAllocated;
    struct gdImageStruct *brush;
    struct gdImageStruct *tile;
    int brushColorMap[256];
    int tileColorMap[256];
    int styleLength;
    int stylePos;
    int *style;
    int interlace;

    int thick;
# 194 "d:/devkitPro/libogc/include/gd.h"
    int alpha[256];


    int trueColor;
    int **tpixels;






    int alphaBlendingFlag;



    int saveAlphaFlag;






    int AA;
    int AA_color;
    int AA_dont_blend;




    int cx1;
    int cy1;
    int cx2;
    int cy2;


    unsigned int res_x;
    unsigned int res_y;
  }
  gdImage;

  typedef gdImage *gdImagePtr;

  typedef struct
  {

    int nchars;

    int offset;

    int w;
    int h;



    char *data;
  }
  gdFont;


  typedef gdFont *gdFontPtr;
# 276 "d:/devkitPro/libogc/include/gd.h"
extern gdImagePtr gdImageCreate (int sx, int sy);





extern gdImagePtr gdImageCreateTrueColor (int sx, int sy);






extern gdImagePtr gdImageCreateFromPng (FILE * fd);
extern gdImagePtr gdImageCreateFromPngCtx (gdIOCtxPtr in);
extern gdImagePtr gdImageCreateFromPngPtr (int size, void *data);


extern gdImagePtr gdImageCreateFromGif (FILE * fd);
extern gdImagePtr gdImageCreateFromGifCtx (gdIOCtxPtr in);
extern gdImagePtr gdImageCreateFromGifPtr (int size, void *data);
extern gdImagePtr gdImageCreateFromWBMP (FILE * inFile);
extern gdImagePtr gdImageCreateFromWBMPCtx (gdIOCtx * infile);
extern gdImagePtr gdImageCreateFromWBMPPtr (int size, void *data);
extern gdImagePtr gdImageCreateFromJpeg (FILE * infile);
extern gdImagePtr gdImageCreateFromJpegCtx (gdIOCtx * infile);
extern gdImagePtr gdImageCreateFromJpegPtr (int size, void *data);

extern gdImagePtr gdImageCreateFromTiff(FILE *inFile);
extern gdImagePtr gdImageCreateFromTiffCtx(gdIOCtx *infile);
extern gdImagePtr gdImageCreateFromTiffPtr(int size, void *data);

extern gdImagePtr gdImageCreateFromTga( FILE * fp );
extern gdImagePtr gdImageCreateFromTgaCtx(gdIOCtx* ctx);
extern gdImagePtr gdImageCreateFromTgaPtr(int size, void *data);

extern gdImagePtr gdImageCreateFromBmp (FILE * inFile);
extern gdImagePtr gdImageCreateFromBmpPtr (int size, void *data);
extern gdImagePtr gdImageCreateFromBmpCtx (gdIOCtxPtr infile);






  typedef struct
  {
    int (*source) (void *context, char *buffer, int len);
    void *context;
  }
  gdSource, *gdSourcePtr;


extern gdImagePtr gdImageCreateFromPngSource (gdSourcePtr in);

extern gdImagePtr gdImageCreateFromGd (FILE * in);
extern gdImagePtr gdImageCreateFromGdCtx (gdIOCtxPtr in);
extern gdImagePtr gdImageCreateFromGdPtr (int size, void *data);

extern gdImagePtr gdImageCreateFromGd2 (FILE * in);
extern gdImagePtr gdImageCreateFromGd2Ctx (gdIOCtxPtr in);
extern gdImagePtr gdImageCreateFromGd2Ptr (int size, void *data);

extern gdImagePtr gdImageCreateFromGd2Part (FILE * in, int srcx, int srcy, int w,
           int h);
extern gdImagePtr gdImageCreateFromGd2PartCtx (gdIOCtxPtr in, int srcx, int srcy,
       int w, int h);
extern gdImagePtr gdImageCreateFromGd2PartPtr (int size, void *data, int srcx, int srcy,
       int w, int h);

extern gdImagePtr gdImageCreateFromXbm (FILE * in);


extern gdImagePtr gdImageCreateFromXpm (char *filename);

extern void gdImageDestroy (gdImagePtr im);
# 360 "d:/devkitPro/libogc/include/gd.h"
extern void gdImageSetPixel (gdImagePtr im, int x, int y, int color);


extern int gdImageGetPixel (gdImagePtr im, int x, int y);
extern int gdImageGetTrueColorPixel (gdImagePtr im, int x, int y);

extern void gdImageAABlend (gdImagePtr im);

extern void gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color);



extern void gdImageDashedLine (gdImagePtr im, int x1, int y1, int x2, int y2,
     int color);


extern void gdImageRectangle (gdImagePtr im, int x1, int y1, int x2, int y2,
    int color);

extern void gdImageFilledRectangle (gdImagePtr im, int x1, int y1, int x2, int y2,
          int color);
extern void gdImageSetClip(gdImagePtr im, int x1, int y1, int x2, int y2);
extern void gdImageGetClip(gdImagePtr im, int *x1P, int *y1P, int *x2P, int *y2P);
extern void gdImageSetResolution(gdImagePtr im, const unsigned int res_x, const unsigned int res_y);
extern int gdImageBoundsSafe (gdImagePtr im, int x, int y);
extern void gdImageChar (gdImagePtr im, gdFontPtr f, int x, int y, int c,
      int color);
extern void gdImageCharUp (gdImagePtr im, gdFontPtr f, int x, int y, int c,
        int color);
extern void gdImageString (gdImagePtr im, gdFontPtr f, int x, int y,
        unsigned char *s, int color);
extern void gdImageStringUp (gdImagePtr im, gdFontPtr f, int x, int y,
   unsigned char *s, int color);
extern void gdImageString16 (gdImagePtr im, gdFontPtr f, int x, int y,
   unsigned short *s, int color);
extern void gdImageStringUp16 (gdImagePtr im, gdFontPtr f, int x, int y,
     unsigned short *s, int color);






extern int gdFontCacheSetup (void);




extern void gdFontCacheShutdown (void);



extern void gdFreeFontCache (void);


extern char * gdImageStringTTF (gdImage * im, int *brect, int fg, char *fontlist,
     double ptsize, double angle, int x, int y,
     char *string);


extern char * gdImageStringFT (gdImage * im, int *brect, int fg, char *fontlist,
    double ptsize, double angle, int x, int y,
    char *string);




  typedef struct
  {
    int flags;
    double linespacing;
    int charmap;




    int hdpi;
    int vdpi;
    char *xshow;







    char *fontpath;
# 456 "d:/devkitPro/libogc/include/gd.h"
  }
  gdFTStringExtra, *gdFTStringExtraPtr;
# 482 "d:/devkitPro/libogc/include/gd.h"
extern int gdFTUseFontConfig(int flag);
# 491 "d:/devkitPro/libogc/include/gd.h"
extern char * gdImageStringFTEx (gdImage * im, int *brect, int fg, char *fontlist,
      double ptsize, double angle, int x, int y,
      char *string, gdFTStringExtraPtr strex);


typedef struct
{
 int x, y;
}
gdPoint, *gdPointPtr;

typedef struct
{
 int x, y;
 int width, height;
}
gdRect, *gdRectPtr;


extern void gdImagePolygon (gdImagePtr im, gdPointPtr p, int n, int c);
extern void gdImageOpenPolygon (gdImagePtr im, gdPointPtr p, int n, int c);
extern void gdImageFilledPolygon (gdImagePtr im, gdPointPtr p, int n, int c);



extern int gdImageColorAllocate (gdImagePtr im, int r, int g, int b);

extern int gdImageColorAllocateAlpha (gdImagePtr im, int r, int g, int b, int a);

extern int gdImageColorClosest (gdImagePtr im, int r, int g, int b);




extern int gdImageColorClosestAlpha (gdImagePtr im, int r, int g, int b, int a);

extern int gdImageColorClosestHWB (gdImagePtr im, int r, int g, int b);

extern int gdImageColorExact (gdImagePtr im, int r, int g, int b);

extern int gdImageColorExactAlpha (gdImagePtr im, int r, int g, int b, int a);

extern int gdImageColorResolve (gdImagePtr im, int r, int g, int b);

extern int gdImageColorResolveAlpha (gdImagePtr im, int r, int g, int b, int a);
# 553 "d:/devkitPro/libogc/include/gd.h"
extern void gdImageColorDeallocate (gdImagePtr im, int color);
# 575 "d:/devkitPro/libogc/include/gd.h"
extern gdImagePtr gdImageCreatePaletteFromTrueColor (gdImagePtr im, int ditherFlag,
      int colorsWanted);

extern void gdImageTrueColorToPalette (gdImagePtr im, int ditherFlag,
      int colorsWanted);
# 590 "d:/devkitPro/libogc/include/gd.h"
extern void gdImageColorTransparent (gdImagePtr im, int color);

extern void gdImagePaletteCopy (gdImagePtr dst, gdImagePtr src);

typedef int (*gdCallbackImageColor)(gdImagePtr im, int src);

extern int gdImageColorReplace(gdImagePtr im, int src, int dst);
extern int gdImageColorReplaceThreshold(gdImagePtr im, int src, int dst, float threshold);
extern int gdImageColorReplaceArray(gdImagePtr im, int len, int *src, int *dst);
extern int gdImageColorReplaceCallback(gdImagePtr im, gdCallbackImageColor callback);

extern void gdImageGif (gdImagePtr im, FILE * out);
extern void gdImagePng (gdImagePtr im, FILE * out);
extern void gdImagePngCtx (gdImagePtr im, gdIOCtx * out);
extern void gdImageGifCtx (gdImagePtr im, gdIOCtx * out);
extern void gdImageTiff(gdImagePtr im, FILE *outFile);
extern void * gdImageTiffPtr(gdImagePtr im, int *size);
extern void gdImageTiffCtx(gdImagePtr image, gdIOCtx *out);

extern void * gdImageBmpPtr(gdImagePtr im, int *size, int compression);
extern void gdImageBmp(gdImagePtr im, FILE *outFile, int compression);
extern void gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression);





extern void gdImagePngEx (gdImagePtr im, FILE * out, int level);
extern void gdImagePngCtxEx (gdImagePtr im, gdIOCtx * out, int level);

extern void gdImageWBMP (gdImagePtr image, int fg, FILE * out);
extern void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out);



extern void gdFree (void *m);


extern void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg);



extern void gdImageJpeg (gdImagePtr im, FILE * out, int quality);
extern void gdImageJpegCtx (gdImagePtr im, gdIOCtx * out, int quality);


extern void * gdImageJpegPtr (gdImagePtr im, int *size, int quality);




enum {
 gdDisposalUnknown,
 gdDisposalNone,
 gdDisposalRestoreBackground,
 gdDisposalRestorePrevious
};

extern void gdImageGifAnimBegin(gdImagePtr im, FILE *outFile, int GlobalCM, int Loops);
extern void gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM, int LeftOfs, int TopOfs, int Delay, int Disposal, gdImagePtr previm);
extern void gdImageGifAnimEnd(FILE *outFile);
extern void gdImageGifAnimBeginCtx(gdImagePtr im, gdIOCtx *out, int GlobalCM, int Loops);
extern void gdImageGifAnimAddCtx(gdImagePtr im, gdIOCtx *out, int LocalCM, int LeftOfs, int TopOfs, int Delay, int Disposal, gdImagePtr previm);
extern void gdImageGifAnimEndCtx(gdIOCtx *out);
extern void * gdImageGifAnimBeginPtr(gdImagePtr im, int *size, int GlobalCM, int Loops);
extern void * gdImageGifAnimAddPtr(gdImagePtr im, int *size, int LocalCM, int LeftOfs, int TopOfs, int Delay, int Disposal, gdImagePtr previm);
extern void * gdImageGifAnimEndPtr(int *size);






  typedef struct
  {
    int (*sink) (void *context, const char *buffer, int len);
    void *context;
  }
  gdSink, *gdSinkPtr;

extern void gdImagePngToSink (gdImagePtr im, gdSinkPtr out);

extern void gdImageGd (gdImagePtr im, FILE * out);
extern void gdImageGd2 (gdImagePtr im, FILE * out, int cs, int fmt);


extern void * gdImageGifPtr (gdImagePtr im, int *size);


extern void * gdImagePngPtr (gdImagePtr im, int *size);
extern void * gdImagePngPtrEx (gdImagePtr im, int *size, int level);


extern void * gdImageGdPtr (gdImagePtr im, int *size);


extern void * gdImageGd2Ptr (gdImagePtr im, int cs, int fmt, int *size);
# 705 "d:/devkitPro/libogc/include/gd.h"
extern void gdImageFilledArc (gdImagePtr im, int cx, int cy, int w, int h, int s,
    int e, int color, int style);
extern void gdImageArc (gdImagePtr im, int cx, int cy, int w, int h, int s, int e,
     int color);
extern void gdImageEllipse(gdImagePtr im, int cx, int cy, int w, int h, int color);
extern void gdImageFilledEllipse (gdImagePtr im, int cx, int cy, int w, int h,
        int color);
extern void gdImageFillToBorder (gdImagePtr im, int x, int y, int border,
       int color);
extern void gdImageFill (gdImagePtr im, int x, int y, int color);
extern void gdImageCopy (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,
      int srcX, int srcY, int w, int h);
extern void gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,
    int srcX, int srcY, int w, int h, int pct);
extern void gdImageCopyMergeGray (gdImagePtr dst, gdImagePtr src, int dstX,
        int dstY, int srcX, int srcY, int w, int h,
        int pct);




extern void gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY,
      int srcX, int srcY, int dstW, int dstH, int srcW,
      int srcH);
# 739 "d:/devkitPro/libogc/include/gd.h"
extern void gdImageCopyResampled (gdImagePtr dst, gdImagePtr src, int dstX,
        int dstY, int srcX, int srcY, int dstW, int dstH,
        int srcW, int srcH);
# 750 "d:/devkitPro/libogc/include/gd.h"
extern void gdImageCopyRotated (gdImagePtr dst,
      gdImagePtr src,
      double dstX, double dstY,
      int srcX, int srcY,
      int srcWidth, int srcHeight, int angle);

extern void gdImageSetBrush (gdImagePtr im, gdImagePtr brush);
extern void gdImageSetTile (gdImagePtr im, gdImagePtr tile);
extern void gdImageSetAntiAliased (gdImagePtr im, int c);
extern void gdImageSetAntiAliasedDontBlend (gdImagePtr im, int c, int dont_blend);
extern void gdImageSetStyle (gdImagePtr im, int *style, int noOfPixels);


extern void gdImageSetThickness (gdImagePtr im, int thickness);

extern void gdImageInterlace (gdImagePtr im, int interlaceArg);
extern void gdImageAlphaBlending (gdImagePtr im, int alphaBlendingArg);
extern void gdImageSaveAlpha (gdImagePtr im, int saveAlphaArg);


extern gdImagePtr gdImageCrop(gdImagePtr src, const gdRect *crop);
extern gdImagePtr gdImageAutoCrop(gdImagePtr im, const unsigned int mode);
extern gdImagePtr gdImageThresholdCrop(gdImagePtr im, const unsigned int color, const float threshold);

extern void gdImageFlipHorizontal(gdImagePtr im);
extern void gdImageFlipVertical(gdImagePtr im);
extern void gdImageFlipBoth(gdImagePtr im);

extern gdImagePtr gdImageNeuQuant(gdImagePtr im, const int max_color, int sample_factor);

enum gdPixelateMode {
 GD_PIXELATE_UPPERLEFT,
 GD_PIXELATE_AVERAGE
};

extern int gdImagePixelate(gdImagePtr im, int block_size, const unsigned int mode);

typedef struct {
 int sub;
 int plus;
 unsigned int num_colors;
 int *colors;
 unsigned int seed;
} gdScatter, *gdScatterPtr;

extern int gdImageScatter(gdImagePtr im, int sub, int plus);
extern int gdImageScatterColor(gdImagePtr im, int sub, int plus, int colors[], unsigned int num_colors);
extern int gdImageScatterEx(gdImagePtr im, gdScatterPtr s);
# 833 "d:/devkitPro/libogc/include/gd.h"
extern gdIOCtx * gdNewFileCtx (FILE *);






extern gdIOCtx * gdNewDynamicCtx (int size, void *data);
# 849 "d:/devkitPro/libogc/include/gd.h"
extern gdIOCtx * gdNewDynamicCtxEx (int size, void *data, int freeFlag);
extern gdIOCtx * gdNewSSCtx (gdSourcePtr in, gdSinkPtr out);
extern void * gdDPExtractData (struct gdIOCtx *ctx, int *size);
# 864 "d:/devkitPro/libogc/include/gd.h"
extern int gdImageCompare (gdImagePtr im1, gdImagePtr im2);
# 879 "d:/devkitPro/libogc/include/gd.h"
}



# 1 "d:/devkitPro/libogc/include/gdfx.h" 1

extern "C" {





# 1 "d:/devkitPro/libogc/include/gd.h" 1

extern "C" {
# 888 "d:/devkitPro/libogc/include/gd.h"
}
# 9 "d:/devkitPro/libogc/include/gdfx.h" 2







 extern gdImagePtr gdImageSquareToCircle(gdImagePtr im, int radius);
# 41 "d:/devkitPro/libogc/include/gdfx.h"
extern char * gdImageStringFTCircle(
 gdImagePtr im,
 int cx,
 int cy,
 double radius,
 double textRadius,
 double fillPortion,
 char *font,
 double points,
 char *top,
 char *bottom,
 int fgcolor);
# 66 "d:/devkitPro/libogc/include/gdfx.h"
 extern void gdImageSharpen (gdImagePtr im, int pct);





}
# 884 "d:/devkitPro/libogc/include/gd.h" 2




}
# 14 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:/devkitPro/libogc/include/debug.h" 1
# 13 "d:/devkitPro/libogc/include/debug.h"
 extern "C" {


extern const char *tcp_localip;
extern const char *tcp_netmask;
extern const char *tcp_gateway;
# 27 "d:/devkitPro/libogc/include/debug.h"
void _break();
# 37 "d:/devkitPro/libogc/include/debug.h"
void DEBUG_Init(s32 device_type,s32 channel_port);


 }
# 15 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2

# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Tools/gecko.h" 1





extern "C"
{


 char ascii(char s);



 void gprintf(const char *str, ...);
 bool InitGecko();
 void hexdump(void *d, int len);
 void USBGeckoOutput();







}
# 17 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Tools/wifi_gecko.h" 1
# 30 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Tools/wifi_gecko.h"
extern "C" {


int WifiGecko_Connect();
void WifiGecko_Close();
int WifiGecko_Send(const char * data, int datasize);
void wifi_printf(const char * format, ...);


}
# 18 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Tools/tools.h" 1
# 30 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Tools/tools.h"
extern "C" {
# 60 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Tools/tools.h"
void ShowError(const char * format, ...);
void ShowMsg(const char * title, const char * format, ...);
void ThrowMsg(const char * title, const char * format, ...);


}
# 19 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Language/gettext.h" 1




extern "C"
{




bool gettextLoadLanguage(const char* langFile);
void gettextCleanUp(void);




const char *gettext(const char *msg);





}
# 20 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 1 3
# 38 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 3
       
# 39 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 1 3
# 153 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 3
namespace std
{
  typedef unsigned int size_t;
  typedef int ptrdiff_t;




}
# 393 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/os_defines.h" 1 3
# 394 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 2 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/cpu_defines.h" 1 3
# 397 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 2 3
# 41 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stringfwd.h" 1 3
# 39 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stringfwd.h" 3
       
# 40 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    class allocator;







  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;
# 85 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stringfwd.h" 3

}
# 42 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/char_traits.h" 1 3
# 39 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/char_traits.h" 3
       
# 40 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/char_traits.h" 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 1 3
# 61 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/functexcept.h" 1 3
# 41 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/functexcept.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/exception_defines.h" 1 3
# 42 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 62 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/cpp_type_traits.h" 1 3
# 36 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/cpp_type_traits.h" 3
       
# 37 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/cpp_type_traits.h" 3
# 69 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 199 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 422 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/cpp_type_traits.h" 3

}
# 63 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/type_traits.h" 1 3
# 33 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/type_traits.h" 3
       
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 64 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/numeric_traits.h" 1 3
# 32 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/numeric_traits.h" 3
       
# 33 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 53) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 15);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 308);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 65 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_pair.h" 1 3
# 60 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_pair.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/move.h" 1 3
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/move.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/concept_check.h" 1 3
# 33 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/concept_check.h" 3
       
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/concept_check.h" 3
# 35 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}
# 109 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 120 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }


}
# 61 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 86 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
 pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
# 196 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 270 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }



}
# 66 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_types.h" 1 3
# 63 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
       
# 64 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 90 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 117 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 163 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };



  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


}
# 67 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 1 3
# 63 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3
       
# 64 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 111 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 169 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
# 200 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator_base_funcs.h" 3

}
# 68 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 1 3
# 68 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 96 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 283 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
# 395 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 422 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 445 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 471 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 486 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 512 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 535 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 561 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 580 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 623 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 649 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 675 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 699 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 797 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}
# 69 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 2 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/debug/debug.h" 1 3
# 47 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 71 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{





  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 116 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 157 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 185 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 208 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 231 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 252 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 319 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 357 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 442 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 494 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 522 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 552 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 611 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 669 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 713 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 773 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 934 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1008 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1040 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1071 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1105 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1145 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1182 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
# 42 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/char_traits.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/postypes.h" 1 3
# 40 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/postypes.h" 3
       
# 41 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/postypes.h" 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cwchar" 1 3
# 41 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cwchar" 3
       
# 42 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cwchar" 3
# 64 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 137 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}
# 43 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/postypes.h" 2 3
# 70 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 92 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
# 113 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 135 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 241 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/postypes.h" 3

}
# 43 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/char_traits.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cwchar" 1 3
# 41 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cwchar" 3
       
# 42 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cwchar" 3
# 44 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 59 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 84 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 228 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(((wint_t)-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}
# 43 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/allocator.h" 1 3
# 48 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/allocator.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++allocator.h" 1 3
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++allocator.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/new_allocator.h" 1 3
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/new_allocator.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 1 3
# 39 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 3
       
# 40 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 1 3
# 35 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
       
# 36 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 61 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 118 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

# 143 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop
# 43 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 93 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 35 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 53 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
# 117 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 35 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++allocator.h" 2 3
# 49 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
# 91 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }




  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
# 236 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/allocator.h" 3

}
# 44 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 2 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/localefwd.h" 1 3
# 39 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/localefwd.h" 3
       
# 40 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/localefwd.h" 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++locale.h" 1 3
# 40 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++locale.h" 3
       
# 41 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++locale.h" 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/clocale" 1 3
# 41 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/clocale" 3
       
# 42 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/clocale" 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/locale.h" 1 3
# 24 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/locale.h" 3
extern "C" {

struct lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_p_sign_posn;
};


char *setlocale (int category, const char *locale);
struct lconv *localeconv (void);


struct _reent;
char *_setlocale_r (struct _reent *, int category, const char *locale);
struct lconv *_localeconv_r (struct _reent *);

}
# 45 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/clocale" 2 3
# 53 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 43 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++locale.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, 0);
    char* __sav = 0;
    if (__builtin_strcmp(__old, "C"))
      {
 const size_t __len = __builtin_strlen(__old) + 1;
 __sav = new char[__len];
 __builtin_memcpy(__sav, __old, __len);
 std::setlocale(4, "C");
      }

    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);




    const int __ret = __builtin_vsprintf(__out, __fmt, __args);


    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }


}
# 43 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/localefwd.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/iosfwd" 1 3
# 38 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/iosfwd" 3
       
# 39 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 44 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/localefwd.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cctype" 1 3
# 41 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cctype" 3
       
# 42 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cctype" 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/ctype.h" 1 3





extern "C" {

int isalnum (int __c);
int isalpha (int __c);
int iscntrl (int __c);
int isdigit (int __c);
int isgraph (int __c);
int islower (int __c);
int isprint (int __c);
int ispunct (int __c);
int isspace (int __c);
int isupper (int __c);
int isxdigit (int __c);
int tolower (int __c);
int toupper (int __c);


int isblank (int __c);



int isascii (int __c);
int toascii (int __c);
# 45 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/ctype.h" 3
extern char *__ctype_ptr__;
# 109 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/ctype.h" 3
extern const char _ctype_[];

}
# 45 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cctype" 2 3
# 64 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
# 45 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
# 46 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/ostream_insert.h" 1 3
# 33 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/ostream_insert.h" 3
       
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/ostream_insert.h" 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/cxxabi_forced.h" 1 3
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/cxxabi_forced.h" 3
       
# 35 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 47 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 2 3



# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 1 3
# 60 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 101 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 140 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 204 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 268 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 351 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 422 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
# 508 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 3
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 541 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/backward/binders.h" 1 3
# 60 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 99 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
# 732 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_function.h" 2 3
# 51 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 2 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/range_access.h" 1 3
# 33 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/range_access.h" 3
       
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/range_access.h" 3
# 54 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 1 3
# 39 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
       
# 40 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/atomicity.h" 1 3
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/atomicity.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/gthr.h" 1 3
# 30 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 174 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/gthr.h" 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/gthr-single.h" 1 3
# 32 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/gthr-single.h" 3
typedef int __gthread_key_t;
typedef int __gthread_once_t;
typedef int __gthread_mutex_t;
typedef int __gthread_recursive_mutex_t;
# 210 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/gthr-single.h" 3
static inline int
__gthread_active_p (void)
{
  return 0;
}

static inline int
__gthread_once (__gthread_once_t *__once __attribute__((unused)), void (*__func) (void) __attribute__((unused)))
{
  return 0;
}

static inline int __attribute__((unused))
__gthread_key_create (__gthread_key_t *__key __attribute__((unused)), void (*__func) (void *) __attribute__((unused)))
{
  return 0;
}

static int __attribute__((unused))
__gthread_key_delete (__gthread_key_t __key __attribute__((unused)))
{
  return 0;
}

static inline void *
__gthread_getspecific (__gthread_key_t __key __attribute__((unused)))
{
  return 0;
}

static inline int
__gthread_setspecific (__gthread_key_t __key __attribute__((unused)), const void *__v __attribute__((unused)))
{
  return 0;
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex __attribute__((unused)))
{
  return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex __attribute__((unused)))
{
  return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex __attribute__((unused)))
{
  return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex __attribute__((unused)))
{
  return 0;
}

static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}
# 175 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/gthr.h" 2 3



#pragma GCC visibility pop
# 35 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/atomicity.h" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/atomic_word.h" 1 3
# 28 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 36 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 63 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {






    return __exchange_and_add_single(__mem, __val);

  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {






    __atomic_add_single(__mem, __val);

  }


}
# 42 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 2 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/initializer_list" 1 3
# 33 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/initializer_list" 3
       
# 34 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/initializer_list" 3
# 44 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 106 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 143 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 168 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 478 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 526 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 559 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 599 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
# 705 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 734 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 747 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
# 767 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 788 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const
      { return this->size() == 0; }
# 817 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 834 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 855 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 908 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
# 964 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
# 979 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 1011 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 1033 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1089 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1105 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1117 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1133 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1145 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 1173 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1188 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1219 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1241 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1264 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1282 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1305 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1322 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1346 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1362 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1382 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1401 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1423 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1447 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1466 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1489 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1507 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1525 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1546 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1567 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1589 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1664 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1745 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1755 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1765 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1797 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1810 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1824 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1841 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1854 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1869 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1882 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1899 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1912 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1927 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1940 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1959 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1973 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1988 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2001 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2020 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 2034 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2049 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2063 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2080 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 2093 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2109 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2122 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2139 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 2154 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2172 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2202 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2226 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2244 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2267 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2292 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2304 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2425 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2471 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2508 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2545 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2582 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2619 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2656 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2673 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2691 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2714 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2732 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}
# 55 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.tcc" 1 3
# 42 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.tcc" 3
       
# 43 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
# 242 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
      
                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 579 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 56 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/string" 2 3
# 23 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/vector" 1 3
# 59 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/vector" 3
       
# 60 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/vector" 3



# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_construct.h" 1 3
# 64 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 78 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_construct.h" 3
  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }





  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 64 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/vector" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_uninitialized.h" 1 3
# 61 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 107 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
     && __is_trivial(_ValueType2))>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 164 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_trivial(_ValueType)>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 218 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 332 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 652 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_uninitialized.h" 3

}
# 65 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/vector" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 1 3
# 65 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 typename _Tp_alloc_type::pointer _M_start;
 typename _Tp_alloc_type::pointer _M_finish;
 typename _Tp_alloc_type::pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
# 141 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      typename _Tp_alloc_type::pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 179 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 262 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 278 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 333 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 361 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 411 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 427 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 454 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 569 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 628 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 649 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 679 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 694 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 709 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 734 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 752 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 801 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      pointer

      data()
      { return std::__addressof(front()); }




      const_pointer

      data() const
      { return std::__addressof(front()); }
# 825 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 856 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 892 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 942 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 960 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 985 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 1006 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1018 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1073 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1147 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1187 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
# 1229 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
      void
      _M_insert_aux(iterator __position, const value_type& __x);







      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 1271 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1288 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 66 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/vector" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_bvector.h" 1 3
# 62 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
# 431 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{

# 478 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;





  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
# 547 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
# 596 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }







    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
# 664 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n);

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }






    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }







    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }





    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };


}
# 67 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/vector" 2 3



# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/vector.tcc" 1 3
# 60 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
   (this->_M_impl._M_start),
   (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
# 106 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
# 128 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::copy(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
# 298 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      (*(this->_M_impl._M_finish - 1))
             );
   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;

   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       this->_M_impl.construct(__new_start + __elems_before,



                               __x);

       __new_finish = 0;

       __new_finish =
  std::__uninitialized_move_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       ++__new_finish;

       __new_finish =
  std::__uninitialized_move_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  this->_M_impl.destroy(__new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish =
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    __new_finish += __n;

    __new_finish =
      std::__uninitialized_move_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }
# 519 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_move_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last,
        __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_move_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }




  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }


}
# 71 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/vector" 2 3
# 24 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../sigslot.h" 1
# 80 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../sigslot.h"
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/set" 1 3
# 58 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/set" 3
       
# 59 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/set" 3

# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_tree.h" 1 3
# 68 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;







    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Link_type>
    (_M_node)->_M_value_field); }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const
      { return iterator(static_cast<typename iterator::_Link_type>
   (const_cast<typename iterator::_Base_ptr>(_M_node))); }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Link_type>
    (_M_node)->_M_value_field); }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }


      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct
       (std::__addressof(__tmp->_M_value_field), __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      {
 get_allocator().destroy(std::__addressof(__p->_M_value_field));
 _M_put_node(__p);
      }
# 424 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_tree.h" 3
      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
# 579 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_tree.h" 3
      iterator
      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,
   const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      iterator
      _M_insert_equal_lower(const value_type& __x);


      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, __a) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }





      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }

      void
      swap(_Rb_tree& __t);
# 723 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_tree.h" 3
      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);

      iterator
      _M_insert_unique_(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal_(const_iterator __position, const value_type& __x);


      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:
# 774 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_tree.h" 3
      void
      erase(iterator __position)
      { _M_erase_aux(__position); }

      void
      erase(const_iterator __position)
      { _M_erase_aux(__position); }

      size_type
      erase(const key_type& __x);
# 795 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_tree.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_erase_aux(__first, __last); }

      void
      erase(const_iterator __first, const_iterator __last)
      { _M_erase_aux(__first, __last); }

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 932 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)

    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node((__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)

    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node((__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal_lower(const _Val& __v)

    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__x, __y, (__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_unique(const _Val& __v)

    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return pair<iterator, bool>
       (_M_insert_(__x, __y, (__v)), true);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>
   (_M_insert_(__x, __y, (__v)), true);
      return pair<iterator, bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal(const _Val& __v)

    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_(__x, __y, (__v));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_unique_(const_iterator __position, const _Val& __v)

    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert_(0, _M_rightmost(), (__v));
   else
     return _M_insert_unique((__v)).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(),
         (__v));
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node,
      (__v));
       else
  return _M_insert_(__position._M_node,
      __position._M_node,
      (__v));
     }
   else
     return _M_insert_unique((__v)).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(),
         (__v));
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node,
      (__v));
       else
  return _M_insert_(__after._M_node, __after._M_node,
      (__v));
     }
   else
     return _M_insert_unique((__v)).first;
 }
      else

 return __position._M_const_cast();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal_(const_iterator __position, const _Val& __v)

    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert_(0, _M_rightmost(),
         (__v));
   else
     return _M_insert_equal((__v));
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(),
         (__v));
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node,
      (__v));
       else
  return _M_insert_(__position._M_node,
      __position._M_node,
      (__v));
     }
   else
     return _M_insert_equal((__v));
 }
      else
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(),
         (__v));
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node,
      (__v));
       else
  return _M_insert_(__after._M_node, __after._M_node,
      (__v));
     }
   else
     return _M_insert_equal_lower((__v));
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }


}
# 61 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/set" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 1 3
# 63 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 87 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      set()
      : _M_t() { }






      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 160 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_unique(__first, __last); }
# 176 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
 { _M_t._M_insert_unique(__first, __last); }
# 190 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      set(const set& __x)
      : _M_t(__x._M_t) { }
# 228 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 276 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 363 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 388 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      void
      swap(set& __x)
      { _M_t.swap(__x._M_t); }
# 406 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 443 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 462 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_unique(__first, __last); }
# 510 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 526 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 560 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 571 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      void
      clear()
      { _M_t.clear(); }
# 585 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 603 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 624 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 640 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 665 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 694 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 711 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 62 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/set" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 1 3
# 63 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 84 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;





      multiset()
      : _M_t() { }






      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 153 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 169 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 183 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
# 221 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 269 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 356 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 381 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      void
      swap(multiset& __x)
      { _M_t.swap(__x._M_t); }
# 397 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 427 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 445 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 493 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 509 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 545 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 556 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      void
      clear()
      { _M_t.clear(); }
# 567 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 585 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 606 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 622 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 647 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 677 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 694 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 63 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/set" 2 3
# 81 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../sigslot.h" 2
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/list" 1 3
# 59 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/list" 3
       
# 60 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/list" 3




# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 1 3
# 63 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace __detail
  {
 
# 76 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
    struct _List_node_base
    {
      _List_node_base* _M_next;
      _List_node_base* _M_prev;

      static void
      swap(_List_node_base& __x, _List_node_base& __y) throw ();

      void
      _M_transfer(_List_node_base* const __first,
    _List_node_base* const __last) throw ();

      void
      _M_reverse() throw ();

      void
      _M_hook(_List_node_base* const __position) throw ();

      void
      _M_unhook() throw ();
    };

 
  }




  template<typename _Tp>
    struct _List_node : public __detail::_List_node_base
    {

      _Tp _M_data;







    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      explicit
      _List_iterator(__detail::_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      __detail::_List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      explicit
      _List_const_iterator(const __detail::_List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const __detail::_List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }



  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 304 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 __detail::_List_node_base _M_node;

 _List_impl()
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator()
      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }
# 371 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 428 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;







      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     _M_get_Tp_allocator().construct
       (std::__addressof(__p->_M_data), __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }
# 506 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
    public:





      list()
      : _Base() { }





      explicit
      list(const allocator_type& __a)
      : _Base(__a) { }
# 557 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_fill_initialize(__n, __value); }
# 571 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 610 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
# 635 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 681 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 697 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 720 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 839 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }
# 889 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type());







      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 945 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
# 972 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 986 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
# 1012 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 1045 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1094 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, _M_get_Node_allocator());
 splice(__position, __tmp);
      }
# 1114 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, _M_get_Node_allocator());
   splice(__position, __tmp);
 }
# 1138 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 1159 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 1176 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      swap(list& __x)
      {
 __detail::_List_node_base::swap(this->_M_impl._M_node,
     __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 1213 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void



      splice(iterator __position, list& __x)

      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }
# 1243 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void



      splice(iterator __position, list& __x, iterator __i)

      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position, __i, __j);
      }
# 1279 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void




      splice(iterator __position, list& __x, iterator __first,
      iterator __last)

      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __first, __last);
   }
      }
# 1314 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1328 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1342 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      unique();
# 1357 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1378 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      merge(list& __x);
# 1404 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&, _StrictWeakOrdering);







      void
      reverse()
      { this->_M_impl._M_node._M_reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n; --__n)
   push_back(__x);
      }
# 1488 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }



      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->_M_hook(__position._M_node);
      }
# 1529 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
      void
      _M_erase(iterator __position)
      {
        __position._M_node->_M_unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);



 _M_get_Tp_allocator().destroy(std::__addressof(__n->_M_data));

        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x)
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
# 1562 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1591 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 65 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/list" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/list.tcc" 1 3
# 60 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/list.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);



   _M_get_Tp_allocator().destroy(std::__addressof(__tmp->_M_data));

   _M_put_node(__tmp);
 }
    }
# 97 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_node);
      return iterator(__tmp);
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }
# 167 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }


  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (std::__addressof(*__first) != std::__addressof(__value))
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::



    merge(list& __x)

    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::



      merge(list& __x, _StrictWeakOrdering __comp)

      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }


}
# 66 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/list" 2 3
# 82 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../sigslot.h" 2
# 94 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../sigslot.h"
namespace sigslot {

 class single_threaded
 {
 public:
  single_threaded()
  {
   ;
  }

  virtual ~single_threaded()
  {
   ;
  }

  virtual void lock()
  {
   ;
  }

  virtual void unlock()
  {
   ;
  }
 };
# 329 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../sigslot.h"
 template<class mt_policy>
 class lock_block
 {
 public:
  mt_policy *m_mutex;

  lock_block(mt_policy *mtx)
   : m_mutex(mtx)
  {
   m_mutex->lock();
  }

  ~lock_block()
  {
   m_mutex->unlock();
  }
 };

 template<class mt_policy>
 class has_slots;

 template<class mt_policy>
 class _connection_base0
 {
 public:
  virtual ~_connection_base0() { ; }
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit() = 0;
  virtual _connection_base0* clone() = 0;
  virtual _connection_base0* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class mt_policy>
 class _connection_base1
 {
 public:
  virtual ~_connection_base1() { ; }
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type) = 0;
  virtual _connection_base1<arg1_type, mt_policy>* clone() = 0;
  virtual _connection_base1<arg1_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class mt_policy>
 class _connection_base2
 {
 public:
  virtual ~_connection_base2() { ; }
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type) = 0;
  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* clone() = 0;
  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class mt_policy>
 class _connection_base3
 {
 public:
  virtual ~_connection_base3() { ; }
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type) = 0;
  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* clone() = 0;
  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy>
 class _connection_base4
 {
 public:
  virtual ~_connection_base4() { ; }
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type) = 0;
  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* clone() = 0;
  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class mt_policy>
 class _connection_base5
 {
 public:
  virtual ~_connection_base5() { ; }
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type) = 0;
  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, mt_policy>* clone() = 0;
  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class mt_policy>
 class _connection_base6
 {
 public:
  virtual ~_connection_base6() { ; }
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
   arg6_type) = 0;
  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, mt_policy>* clone() = 0;
  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class mt_policy>
 class _connection_base7
 {
 public:
  virtual ~_connection_base7() { ; }
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
   arg6_type, arg7_type) = 0;
  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, mt_policy>* clone() = 0;
  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy>
 class _connection_base8
 {
 public:
  virtual ~_connection_base8() { ; }
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
   arg6_type, arg7_type, arg8_type) = 0;
  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* clone() = 0;
  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class mt_policy>
 class _signal_base : public mt_policy
 {
 public:
  virtual void slot_disconnect(has_slots<mt_policy>* pslot) = 0;
  virtual void slot_duplicate(const has_slots<mt_policy>* poldslot, has_slots<mt_policy>* pnewslot) = 0;
 };

 template<class mt_policy = single_threaded>
 class has_slots : public mt_policy
 {
 private:
  typedef typename std::set<_signal_base<mt_policy> *> sender_set;
  typedef typename sender_set::const_iterator const_iterator;

 public:
  has_slots()
  {
   ;
  }

  has_slots(const has_slots& hs)
   : mt_policy(hs)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = hs.m_senders.begin();
   const_iterator itEnd = hs.m_senders.end();

   while(it != itEnd)
   {
    (*it)->slot_duplicate(&hs, this);
    m_senders.insert(*it);
    ++it;
   }
  }

  void signal_connect(_signal_base<mt_policy>* sender)
  {
   lock_block<mt_policy> lock(this);
   m_senders.insert(sender);
  }

  void signal_disconnect(_signal_base<mt_policy>* sender)
  {
   lock_block<mt_policy> lock(this);
   m_senders.erase(sender);
  }

  virtual ~has_slots()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_senders.begin();
   const_iterator itEnd = m_senders.end();

   while(it != itEnd)
   {
    (*it)->slot_disconnect(this);
    ++it;
   }

   m_senders.erase(m_senders.begin(), m_senders.end());
  }

 private:
  sender_set m_senders;
 };

 template<class mt_policy>
 class _signal_base0 : public _signal_base<mt_policy>
 {
 public:
  typedef typename std::list<_connection_base0<mt_policy> *> connections_list;
  typedef typename connections_list::const_iterator const_iterator;
  typedef typename connections_list::iterator iterator;

  _signal_base0()
  {
   ;
  }

  _signal_base0(const _signal_base0& s)
   : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = s.m_connected_slots.begin();
   const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  ~_signal_base0()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_connected_slots.begin();
   const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  bool connected()
  {
   return m_connected_slots.size() != 0;
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);

    }

    it = itNext;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class mt_policy>
 class _signal_base1 : public _signal_base<mt_policy>
 {
 public:
  typedef typename std::list<_connection_base1<arg1_type, mt_policy> *> connections_list;
  typedef typename connections_list::const_iterator const_iterator;
  typedef typename connections_list::iterator iterator;

  _signal_base1()
  {
   ;
  }

  _signal_base1(const _signal_base1<arg1_type, mt_policy>& s)
   : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = s.m_connected_slots.begin();
   const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base1()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_connected_slots.begin();
   const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  bool connected()
  {
   return m_connected_slots.size() != 0;
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);

    }

    it = itNext;
   }
  }


 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class mt_policy>
 class _signal_base2 : public _signal_base<mt_policy>
 {
 public:
  typedef typename std::list<_connection_base2<arg1_type, arg2_type, mt_policy> *>
   connections_list;
  typedef typename connections_list::const_iterator const_iterator;
  typedef typename connections_list::iterator iterator;

  _signal_base2()
  {
   ;
  }

  _signal_base2(const _signal_base2<arg1_type, arg2_type, mt_policy>& s)
   : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = s.m_connected_slots.begin();
   const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base2()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_connected_slots.begin();
   const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  bool connected()
  {
   return m_connected_slots.size() != 0;
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);

    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class mt_policy>
 class _signal_base3 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base3<arg1_type, arg2_type, arg3_type, mt_policy> *>
   connections_list;

  typedef typename connections_list::const_iterator const_iterator;
  typedef typename connections_list::iterator iterator;
  _signal_base3()
  {
   ;
  }

  _signal_base3(const _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>& s)
   : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = s.m_connected_slots.begin();
   const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base3()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_connected_slots.begin();
   const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  bool connected()
  {
   return m_connected_slots.size() != 0;
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);

    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy>
 class _signal_base4 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base4<arg1_type, arg2_type, arg3_type,
   arg4_type, mt_policy> *> connections_list;
  typedef typename connections_list::const_iterator const_iterator;
  typedef typename connections_list::iterator iterator;

  _signal_base4()
  {
   ;
  }

  _signal_base4(const _signal_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>& s)
   : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = s.m_connected_slots.begin();
   const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base4()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_connected_slots.begin();
   const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     this->m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  bool connected()
  {
   return m_connected_slots.size() != 0;
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);

    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class mt_policy>
 class _signal_base5 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base5<arg1_type, arg2_type, arg3_type,
   arg4_type, arg5_type, mt_policy> *> connections_list;
  typedef typename connections_list::const_iterator const_iterator;
  typedef typename connections_list::iterator iterator;

  _signal_base5()
  {
   ;
  }

  _signal_base5(const _signal_base5<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, mt_policy>& s)
   : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = s.m_connected_slots.begin();
   const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base5()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_connected_slots.begin();
   const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  bool connected()
  {
   return m_connected_slots.size() != 0;
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);

    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class mt_policy>
 class _signal_base6 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base6<arg1_type, arg2_type, arg3_type,
   arg4_type, arg5_type, arg6_type, mt_policy> *> connections_list;
  typedef typename connections_list::const_iterator const_iterator;
  typedef typename connections_list::iterator iterator;

  _signal_base6()
  {
   ;
  }

  _signal_base6(const _signal_base6<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, mt_policy>& s)
   : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = s.m_connected_slots.begin();
   const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base6()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_connected_slots.begin();
   const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  bool connected()
  {
   return m_connected_slots.size() != 0;
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);

    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class mt_policy>
 class _signal_base7 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base7<arg1_type, arg2_type, arg3_type,
   arg4_type, arg5_type, arg6_type, arg7_type, mt_policy> *> connections_list;
  typedef typename connections_list::const_iterator const_iterator;
  typedef typename connections_list::iterator iterator;

  _signal_base7()
  {
   ;
  }

  _signal_base7(const _signal_base7<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, mt_policy>& s)
   : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = s.m_connected_slots.begin();
   const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base7()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_connected_slots.begin();
   const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  bool connected()
  {
   return m_connected_slots.size() != 0;
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);

    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy>
 class _signal_base8 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base8<arg1_type, arg2_type, arg3_type,
   arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy> *>
   connections_list;
  typedef typename connections_list::const_iterator const_iterator;
  typedef typename connections_list::iterator iterator;

  _signal_base8()
  {
   ;
  }

  _signal_base8(const _signal_base8<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>& s)
   : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = s.m_connected_slots.begin();
   const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base8()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_connected_slots.begin();
   const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  bool connected()
  {
   return m_connected_slots.size() != 0;
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   iterator it = m_connected_slots.begin();
   iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);

    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };


 template<class dest_type, class mt_policy>
 class _connection0 : public _connection_base0<mt_policy>
 {
 public:
  _connection0()
  {
   this->pobject = __null;
   this->pmemfun = __null;
  }

  _connection0(dest_type* pobject, void (dest_type::*pmemfun)())
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual ~_connection0()
  {
   ;
  }

  virtual _connection_base0<mt_policy>* clone()
  {
   return new _connection0<dest_type, mt_policy>(*this);
  }

  virtual _connection_base0<mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection0<dest_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit()
  {
   (m_pobject->*m_pmemfun)();
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)();
 };

 template<class dest_type, class arg1_type, class mt_policy>
 class _connection1 : public _connection_base1<arg1_type, mt_policy>
 {
 public:
  _connection1()
  {
   this->pobject = __null;
   this->pmemfun = __null;
  }

  _connection1(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual ~_connection1()
  {
   ;
  }

  virtual _connection_base1<arg1_type, mt_policy>* clone()
  {
   return new _connection1<dest_type, arg1_type, mt_policy>(*this);
  }

  virtual _connection_base1<arg1_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection1<dest_type, arg1_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1)
  {
   (m_pobject->*m_pmemfun)(a1);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class mt_policy>
 class _connection2 : public _connection_base2<arg1_type, arg2_type, mt_policy>
 {
 public:
  _connection2()
  {
   this->pobject = __null;
   this->pmemfun = __null;
  }

  _connection2(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
   arg2_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual ~_connection2()
  {
   ;
  }


  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* clone()
  {
   return new _connection2<dest_type, arg1_type, arg2_type, mt_policy>(*this);
  }

  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection2<dest_type, arg1_type, arg2_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2)
  {
   (m_pobject->*m_pmemfun)(a1, a2);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type, class mt_policy>
 class _connection3 : public _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>
 {
 public:
  _connection3()
  {
   this->pobject = __null;
   this->pmemfun = __null;
  }

  _connection3(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
   arg2_type, arg3_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

    virtual ~_connection3()
    {
      ;
    }


  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* clone()
  {
   return new _connection3<dest_type, arg1_type, arg2_type, arg3_type, mt_policy>(*this);
  }

  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection3<dest_type, arg1_type, arg2_type, arg3_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class mt_policy>
 class _connection4 : public _connection_base4<arg1_type, arg2_type,
  arg3_type, arg4_type, mt_policy>
 {
 public:
  _connection4()
  {
   this->pobject = __null;
   this->pmemfun = __null;
  }

  _connection4(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
   arg2_type, arg3_type, arg4_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

    virtual ~_connection4()
    {
      ;
    }

  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* clone()
  {
   return new _connection4<dest_type, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>(*this);
  }

  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection4<dest_type, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3,
   arg4_type a4)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type,
   arg4_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class mt_policy>
 class _connection5 : public _connection_base5<arg1_type, arg2_type,
  arg3_type, arg4_type, arg5_type, mt_policy>
 {
 public:
  _connection5()
  {
   this->pobject = __null;
   this->pmemfun = __null;
  }

  _connection5(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
   arg2_type, arg3_type, arg4_type, arg5_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

    virtual ~_connection5()
    {
      ;
    }

  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, mt_policy>* clone()
  {
   return new _connection5<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, mt_policy>(*this);
  }

  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection5<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class arg6_type, class mt_policy>
 class _connection6 : public _connection_base6<arg1_type, arg2_type,
  arg3_type, arg4_type, arg5_type, arg6_type, mt_policy>
 {
 public:
  _connection6()
  {
   this->pobject = __null;
   this->pmemfun = __null;
  }

  _connection6(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
   arg2_type, arg3_type, arg4_type, arg5_type, arg6_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

    virtual ~_connection6()
    {
      ;
    }

  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, mt_policy>* clone()
  {
   return new _connection6<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, arg6_type, mt_policy>(*this);
  }

  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection6<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, arg6_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5, arg6_type a6)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class arg6_type, class arg7_type, class mt_policy>
 class _connection7 : public _connection_base7<arg1_type, arg2_type,
  arg3_type, arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>
 {
 public:
  _connection7()
  {
   this->pobject = __null;
   this->pmemfun = __null;
  }

  _connection7(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
   arg2_type, arg3_type, arg4_type, arg5_type, arg6_type, arg7_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

    virtual ~_connection7()
    {
      ;
    }

  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, mt_policy>* clone()
  {
   return new _connection7<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, arg6_type, arg7_type, mt_policy>(*this);
  }

  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection7<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, arg6_type, arg7_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5, arg6_type a6, arg7_type a7)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6, a7);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class arg6_type, class arg7_type,
 class arg8_type, class mt_policy>
 class _connection8 : public _connection_base8<arg1_type, arg2_type,
  arg3_type, arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>
 {
 public:
  _connection8()
  {
   this->pobject = __null;
   this->pmemfun = __null;
  }

  _connection8(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
   arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
   arg7_type, arg8_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

    virtual ~_connection8()
    {
      ;
    }

  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* clone()
  {
   return new _connection8<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>(*this);
  }

  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection8<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6, a7, a8);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, arg8_type);
 };

 template<class mt_policy = single_threaded>
 class signal0 : public _signal_base0<mt_policy>
 {
 public:
  typedef typename _signal_base0<mt_policy>::connections_list::const_iterator const_iterator;
  signal0()
  {
   ;
  }

  signal0(const signal0<mt_policy>& s)
   : _signal_base0<mt_policy>(s)
  {
   ;
  }

  virtual ~signal0()
  {
   ;
  }

  template<class desttype>
   void connect(desttype* pclass, void (desttype::*pmemfun)())
  {
   lock_block<mt_policy> lock(this);
   _connection0<desttype, mt_policy>* conn =
    new _connection0<desttype, mt_policy>(pclass, pmemfun);
   this->m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit()
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit();

    it = itNext;
   }
  }

  void operator()()
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit();

    it = itNext;
   }
  }
 };

 template<class arg1_type, class mt_policy = single_threaded>
 class signal1 : public _signal_base1<arg1_type, mt_policy>
 {
 public:
  typedef typename _signal_base1<arg1_type, mt_policy>::connections_list::const_iterator const_iterator;
  signal1()
  {
   ;
  }

  signal1(const signal1<arg1_type, mt_policy>& s)
   : _signal_base1<arg1_type, mt_policy>(s)
  {
   ;
  }

  virtual ~signal1()
  {
   ;
  }

  template<class desttype>
   void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type))
  {
   lock_block<mt_policy> lock(this);
   _connection1<desttype, arg1_type, mt_policy>* conn =
    new _connection1<desttype, arg1_type, mt_policy>(pclass, pmemfun);
   this->m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1);

    it = itNext;
   }
  }

  void operator()(arg1_type a1)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1);

    it = itNext;
   }
  }
 };

 template<class arg1_type, typename arg2_type, typename mt_policy = single_threaded>
 class signal2 : public _signal_base2<arg1_type, arg2_type, mt_policy>
 {
 public:
  typedef typename _signal_base2<arg1_type, arg2_type, mt_policy>::connections_list::const_iterator const_iterator;
  signal2()
  {
   ;
  }

  signal2(const signal2<arg1_type, arg2_type, mt_policy>& s)
   : _signal_base2<arg1_type, arg2_type, mt_policy>(s)
  {
   ;
  }

  virtual ~signal2()
  {
   ;
  }

  template<class desttype>
   void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
   arg2_type))
  {
   lock_block<mt_policy> lock(this);
   _connection2<desttype, arg1_type, arg2_type, mt_policy>* conn = new
    _connection2<desttype, arg1_type, arg2_type, mt_policy>(pclass, pmemfun);
   this->m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2);

    it = itNext;
   }
  }
 };

 template<class arg1_type, typename arg2_type, typename arg3_type, typename mt_policy = single_threaded>
 class signal3 : public _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>
 {
 public:
  typedef typename _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>::connections_list::const_iterator const_iterator;
  signal3()
  {
   ;
  }

  signal3(const signal3<arg1_type, arg2_type, arg3_type, mt_policy>& s)
   : _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>(s)
  {
   ;
  }

  virtual ~signal3()
  {
   ;
  }

  template<class desttype>
   void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
   arg2_type, arg3_type))
  {
   lock_block<mt_policy> lock(this);
   _connection3<desttype, arg1_type, arg2_type, arg3_type, mt_policy>* conn =
    new _connection3<desttype, arg1_type, arg2_type, arg3_type, mt_policy>(pclass,
    pmemfun);
   this->m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy = single_threaded>
 class signal4 : public _signal_base4<arg1_type, arg2_type, arg3_type,
  arg4_type, mt_policy>
 {
 public:
  typedef typename _signal_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>::connections_list::const_iterator const_iterator;
  signal4()
  {
   ;
  }

  signal4(const signal4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>& s)
   : _signal_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>(s)
  {
   ;
  }

  virtual ~signal4()
  {
   ;
  }

  template<class desttype>
   void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
   arg2_type, arg3_type, arg4_type))
  {
   lock_block<mt_policy> lock(this);
   _connection4<desttype, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>*
    conn = new _connection4<desttype, arg1_type, arg2_type, arg3_type,
    arg4_type, mt_policy>(pclass, pmemfun);
   this->m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class mt_policy = single_threaded>
 class signal5 : public _signal_base5<arg1_type, arg2_type, arg3_type,
  arg4_type, arg5_type, mt_policy>
 {
 public:
  typedef typename _signal_base5<arg1_type, arg2_type, arg3_type, arg4_type, arg5_type, mt_policy>::connections_list::const_iterator const_iterator;
  signal5()
  {
   ;
  }

  signal5(const signal5<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, mt_policy>& s)
   : _signal_base5<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, mt_policy>(s)
  {
   ;
  }

  virtual ~signal5()
  {
   ;
  }

  template<class desttype>
   void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
   arg2_type, arg3_type, arg4_type, arg5_type))
  {
   lock_block<mt_policy> lock(this);
   _connection5<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, mt_policy>* conn = new _connection5<desttype, arg1_type, arg2_type,
    arg3_type, arg4_type, arg5_type, mt_policy>(pclass, pmemfun);
   this->m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5);

    it = itNext;
   }
  }
 };


 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class mt_policy = single_threaded>
 class signal6 : public _signal_base6<arg1_type, arg2_type, arg3_type,
  arg4_type, arg5_type, arg6_type, mt_policy>
 {
 public:
  typedef typename _signal_base6<arg1_type, arg2_type, arg3_type,
  arg4_type, arg5_type, arg6_type, mt_policy>::connections_list::const_iterator const_iterator;
  signal6()
  {
   ;
  }

  signal6(const signal6<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, mt_policy>& s)
   : _signal_base6<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, mt_policy>(s)
  {
   ;
  }

  virtual ~signal6()
  {
   ;
  }

  template<class desttype>
   void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
   arg2_type, arg3_type, arg4_type, arg5_type, arg6_type))
  {
   lock_block<mt_policy> lock(this);
   _connection6<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, arg6_type, mt_policy>* conn =
    new _connection6<desttype, arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, arg6_type, mt_policy>(pclass, pmemfun);
   this->m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5, arg6_type a6)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5, arg6_type a6)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class mt_policy = single_threaded>
 class signal7 : public _signal_base7<arg1_type, arg2_type, arg3_type,
  arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>
 {
 public:
  typedef typename _signal_base7<arg1_type, arg2_type, arg3_type,
  arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>::connections_list::const_iterator const_iterator;
  signal7()
  {
   ;
  }

  signal7(const signal7<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, mt_policy>& s)
   : _signal_base7<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, mt_policy>(s)
  {
   ;
  }

  virtual ~signal7()
  {
   ;
  }

  template<class desttype>
   void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
   arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
   arg7_type))
  {
   lock_block<mt_policy> lock(this);
   _connection7<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, arg6_type, arg7_type, mt_policy>* conn =
    new _connection7<desttype, arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>(pclass, pmemfun);
   this->m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5, arg6_type a6, arg7_type a7)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5, arg6_type a6, arg7_type a7)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy = single_threaded>
 class signal8 : public _signal_base8<arg1_type, arg2_type, arg3_type,
  arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>
 {
 public:
  typedef typename _signal_base8<arg1_type, arg2_type, arg3_type,
  arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>::connections_list::const_iterator const_iterator;
  signal8()
  {
   ;
  }

  signal8(const signal8<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>& s)
   : _signal_base8<arg1_type, arg2_type, arg3_type, arg4_type,
   arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>(s)
  {
   ;
  }

  virtual ~signal8()
  {
   ;
  }

  template<class desttype>
   void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
   arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
   arg7_type, arg8_type))
  {
   lock_block<mt_policy> lock(this);
   _connection8<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
    arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* conn =
    new _connection8<desttype, arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, arg6_type, arg7_type,
    arg8_type, mt_policy>(pclass, pmemfun);
   this->m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7, a8);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
   arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
  {
   lock_block<mt_policy> lock(this);
   const_iterator itNext, it = this->m_connected_slots.begin();
   const_iterator itEnd = this->m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7, a8);

    it = itNext;
   }
  }
 };

};
# 25 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Tools/StringTools.h" 1
# 32 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Tools/StringTools.h"
const char * fmt(const char * format, ...);
const wchar_t * wfmt(const char * format, ...);
int strprintf(std::string &str, const char * format, ...);
std::string strfmt(const char * format, ...);
bool char2wchar_t(const char * src, wchar_t * dest);
int strtokcmp(const char * string, const char * compare, const char * separator);
std::string wstr2str(std::wstring wstr);
std::string StringReplace(std::string txt, std::string Before, std::string After);

inline const char * FullpathToFilename(const char *path)
{
 if(!path) return path;

 const char * ptr = path;
 const char * Filename = ptr;

 while(*ptr != '\0')
 {
  if(ptr[0] == '/' && ptr[1] != '\0')
   Filename = ptr+1;

  ++ptr;
 }

 return Filename;
}

inline void RemoveDoubleSlashs(std::string &str)
{
 u32 length = str.size();


 for(u32 i = 1; i < length; ++i)
 {
  if(str[i-1] == '/' && str[i] == '/')
  {
   str.erase(i, 1);
   i--;
   length--;
  }
 }
}
# 26 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/CSettings.h" 1
# 31 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/CSettings.h"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/SettingsEnums.h" 1



enum
{
 JAPANESE = 0,
 ENGLISH,
 GERMAN,
 FRENCH,
 SPANISH,
 ITALIAN,
 DUTCH,
 S_CHINESE,
 T_CHINESE,
 KOREAN,
 CONSOLE_DEFAULT,
 MAX_LANGUAGE,
};

enum
{
 OFF = 0,
 ON,
 MAX_ON_OFF
};

enum
{
 ICONBROWSER = 0,
 LISTBROWSER,
};
# 45 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/SettingsEnums.h"
enum
{
 CLOCK_HR12 = 1,
 CLOCK_HR24,
 CLOCK_MAX
};

enum
{
 SCREENSAVER_1_MIN = 1,
 SCREENSAVER_3_MIN,
 SCREENSAVER_5_MIN,
 SCREENSAVER_10_MIN,
 SCREENSAVER_20_MIN,
 SCREENSAVER_30_MIN,
 SCREENSAVER_60_MIN,
 SCREENSAVER_MAX
};
# 74 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/SettingsEnums.h"
enum
{
 LANG_UPDATE_OFF = 0,
 LANG_UPDATE_ALL,
 LANG_UPDATE_INSTALLED,
 LANG_UPDATE_MAX
};

enum
{
 SCREENSHOT_PNG,
 SCREENSHOT_JPEG,
 SCREENSHOT_GIF,
 SCREENSHOT_TIFF,
 SCREENSHOT_BMP,
 SCREENSHOT_GD,
 SCREENSHOT_GD2,
 SCREENSHOT_MAX
};

enum
{
 TYPE_WII = 0,
 TYPE_WIIWARE,
 TYPE_GAMECUBE,
 TYPE_VC_NES,
 TYPE_VC_SNES,
 TYPE_VC_N64,
 TYPE_VC_SMS,
 TYPE_VC_MD,
 TYPE_VC_PCE,
 TYPE_VC_NEOGEO,
 TYPE_VC_ARCADE,
 TYPE_VC_C64,
 TYPE_CHANNEL,
 TYPE_UNKNOW,
 TYPE_MAX
};

enum
{
 BLOCK_NONE = 0x000000,
 BLOCK_GLOBAL_SETTINGS = 0x000001,
 BLOCK_GUI_SETTINGS = 0x000002,
 BLOCK_AUDIO_SETTINGS = 0x000004,
 BLOCK_CUSTOMPATH_SETTINGS = 0x000008,
 BLOCK_THEME_SETTINGS = 0x000010,
 BLOCK_CONTROLS_SETTINGS = 0x000020,
 BLOCK_PARENTAL_SETTINGS = 0x000040,
 BLOCK_FEATURES_MENU = 0x000080,
 BLOCK_UPDATES = 0x000100,
 BLOCK_RESET_SETTINGS = 0x000200,
 BLOCK_MANAGE_EMUNAND = 0x000400,
 BLOCK_MANAGE_DATABIN = 0x000800,
 BLOCK_MANAGE_ALL = 0x001000,
 BLOCK_MANAGE = 0x002000,
 BLOCK_HBC_MENU = 0x004000,
 BLOCK_TITLE_LAUNCHER = 0x008000,
 BLOCK_SD_RELOAD_BUTTON = 0x010000,
 BLOCK_WIISAVE_DOWNLOAD = 0x020000,
 BLOCK_ALL = 0xFFFFFFFF,
};

enum
{
 HOME_MENU_SYSTEM,
 HOME_MENU_FULL,
 HOME_MENU_DEFAULT,
 HOME_MENU_MAX
};

enum
{
 SEARCH_BEGINNING,
 SEARCH_CONTENT,
 SEARCH_MAX
};

enum
{
 ONCE,
 LOOP,
 RANDOM_MUSIC,
 PLAYLIST_LOOP,
 MAX_LOOP_MODES
};
# 32 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/CSettings.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/../FileOperations/FileExtensions.h" 1
# 29 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/../FileOperations/FileExtensions.h"
class CFilesExtensions
{
 public:
  CFilesExtensions();
  ~CFilesExtensions();
  void SetDefault();


  void SetAudio(const char * ext);
  void SetImage(const char * ext);
  void SetArchive(const char * ext);
  void SetHomebrew(const char * ext);
  void SetFont(const char * ext);
  void SetLanguageFiles(const char * ext);
  void SetThemeFiles(const char * ext);
  void SetMiiFiles(const char * ext);
  void SetBinaryFiles(const char * ext);


  const char * GetAudio() { return AudioFiles; }
  const char * GetImage() { return ImageFiles; }
  const char * GetArchive() { return ArchiveFiles; }
  const char * GetHomebrew() { return HomebrewFiles; }
  const char * GetFont() { return FontFiles; }
  const char * GetLanguageFiles() { return LanguageFiles; }
  const char * GetThemeFiles() { return ThemeFiles; }
  const char * GetMiiFiles() { return MiiFiles; }
  const char * GetBinaryFiles() { return BinaryFiles; }


  int CompareAudio(const char * ext);
  int CompareImage(const char * ext);
  int CompareArchive(const char * ext);
  int CompareHomebrew(const char * ext);
  int CompareFont(const char * ext);
  int CompareLanguageFiles(const char * ext);
  int CompareThemeFiles(const char * ext);
  int CompareMiiFiles(const char * ext);
  int CompareBinaryFiles(const char * ext);

 protected:
  void Clear();
  char * AudioFiles;
  char * ImageFiles;
  char * ArchiveFiles;
  char * HomebrewFiles;
  char * FontFiles;
  char * LanguageFiles;
  char * ThemeFiles;
  char * MiiFiles;
  char * BinaryFiles;
};
# 33 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/CSettings.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/../Controls/AppControls.hpp" 1
# 35 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/../Controls/AppControls.hpp"
typedef struct _Controls
{
 u16 ClickButton;
 u16 BackButton;
 u16 UpButton;
 u16 DownButton;
 u16 LeftButton;
 u16 RightButton;
 u16 NextButton;
 u16 PrevButton;
 u16 HomeButton;
 u16 KeyShiftButton;
 u16 KeyBackspaceButton;
 u16 UpInDirectory;
 u16 OneButtonScroll;
 u16 EditTextLine;
} ControlItems;

class AppControls
{
 public:
  AppControls();
  ~AppControls();
  void SetDefault();
  bool Load(std::string filepath);
  bool Save();
  bool SetControl(char *name, char *value);

  ControlItems WiiControls;
  ControlItems ClassicControls;
  ControlItems GCControls;



 protected:
  std::string FilePath;
  void ParseLine(char *line);
  void TrimLine(char *dest, char *src, int size);
};
# 34 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/CSettings.h" 2

class CSettings
{
 public:

  CSettings();

  ~CSettings();

  void SetDefault();

  bool Load();

  bool Save();

  bool Reset();


  bool LoadLanguage(const char *path, int language = -1);


  std::string LastUsedPath;




  char BootDevice[10];
  char ConfigPath[80];
  bool updateChecked;


  short BrowserMode;

  short SearchMode;

  short Rumble;

  short Clock;

  short Tooltips;

  int TooltipDelay;

  f32 FontScaleFactor;

  f32 ClockFontScaleFactor;

  f32 PointerSpeed;

  short ScrollSpeed;

  short KeyboardDeleteDelay;

  short SoundblockCount;

  int SoundblockSize;

  short USBPort;

  short Screensaver;

  short HomeMenu;

  short UseSystemFont;

  char ThemePath[250];
  char Theme[100];

  char UpdatePath[250];

  char SaveGamePath[250];


  char MusicPath[250];

  int MusicVolume;

  int SFXVolume;

  int CreditsVolume;

  short BGMLoopMode;



  short GodMode;
  char unlockCode[20];
  short RememberUnlock;
  u32 ParentalBlocks;


  char GameTDBLanguageCode[20];


  short AutoConnect;

  short UpdateIcon;

  short UpdateLanguage;

  short UpdateGameTDB;

  short Wiiload;
# 168 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Settings/CSettings.h"
  char LanguageFile[250];

  char LanguagePath[250];

  char CustomFontPath[250];

  char GameTDBPath[250];

  char ScreenshotPath[250];

  short ScreenshotFormat;

  short cIOS;

  u8 EntryIOS;



  short Widescreen;
  bool PAL50;





  CFilesExtensions FileExtensions;

  AppControls Controls;

 protected:
  bool ValidVersion(FILE * file);
  bool SetSetting(char *name, char *value);

  bool FindConfig();

  void ParseLine(char *line);
  void TrimLine(char *dest, char *src, int size);
};

extern CSettings Settings;
# 27 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../stdafx.h" 2





extern u32 frameCount;
extern int screenwidth;
extern int screenheight;
# 21 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_element.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Tools/Rect.h" 1



template<class T>
class Rect
{
public:
 Rect<T>()
  : fx1(0), fy1(0), fx2(0), fy2(0)
 {}

 Rect<T>(const Rect &r)
  : fx1(r.fx1), fy1(r.fy1), fx2(r.fx2), fy2(r.fy2)
 {}

 Rect<T>(T x, T y, T x2, T y2)
  : fx1(x), fy1(y), fx2(x2), fy2(y2)
 {}

 ~Rect() {}

 void setValues(T x, T y, T x2, T y2) {
  fx1 = x;
  fy1 = y;
  fx2 = x2;
  fy2 = y2;
 }

 const Rect &operator=(const Rect &r) {
  this->fx1 = r.fx1;
  this->fx2 = r.fx2;
  this->fy1 = r.fy1;
  this->fy2 = r.fy2;
  return *this;
 }

 T x1() const { return fx1; }
 T y1() const { return fy1; }
 T x2() const { return fx2; }
 T y2() const { return fy2; }

private:
 T fx1, fy1, fx2, fy2;
};

typedef Rect<int> iRect;
typedef Rect<float> fRect;
# 22 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_element.h" 2

enum
{
 EFFECT_NONE = 0x0000,
 EFFECT_SLIDE_TOP = 0x0001,
 EFFECT_SLIDE_BOTTOM = 0x0002,
 EFFECT_SLIDE_RIGHT = 0x0004,
 EFFECT_SLIDE_LEFT = 0x0008,
 EFFECT_SLIDE_IN = 0x0010,
 EFFECT_SLIDE_OUT = 0x0020,
 EFFECT_SLIDE_FROM = 0x0040,
 EFFECT_FADE = 0x0080,
 EFFECT_SCALE = 0x0100,
 EFFECT_COLOR_TRANSITION = 0x0200,
 EFFECT_MOVE = 0x0400,
 EFFECT_MOVE_VERT = 0x0800,
 EFFECT_MOVE_HOR = 0x1000,
 EFFECT_PULSE = 0x2000,
};

enum
{
 ALIGN_LEFT = 0x01,
 ALIGN_CENTER = 0x02,
 ALIGN_RIGHT = 0x04,
 ALIGN_TOP = 0x10,
 ALIGN_MIDDLE = 0x20,
 ALIGN_BOTTOM = 0x40,
 ALIGN_TOP_LEFT = ALIGN_LEFT | ALIGN_TOP,
 ALIGN_TOP_CENTER = ALIGN_CENTER | ALIGN_TOP,
 ALIGN_TOP_RIGHT = ALIGN_RIGHT | ALIGN_TOP,
 ALIGN_CENTERED = ALIGN_CENTER | ALIGN_MIDDLE,
};

enum
{
 STATE_DEFAULT,
 STATE_SELECTED,
 STATE_CLICKED,
 STATE_HELD,
 STATE_DISABLED,
 STATE_CLOSED
};

enum
{
 WRAP,
 DOTTED,
 SCROLL_HORIZONTAL,
 SCROLL_NONE
};

typedef struct _POINT {
 s32 x;
 s32 y;
} POINT;


class GuiTrigger;


class GuiElement
{
 public:

  GuiElement();

  virtual ~GuiElement() {}


  virtual void SetParent(GuiElement * e) { parentElement = e; }


  virtual GuiElement * GetParent() { return parentElement; }



  virtual int GetLeft();



  virtual int GetTop();


  virtual int GetZPosition()
  {
   int zParent = 0;

   if(parentElement)
    zParent = parentElement->GetZPosition();

   return zParent+zoffset;
  }

  virtual int GetLeftPos() { return xoffset; }

  virtual int GetTopPos() { return yoffset; }


  virtual int GetWidth() { return width; };


  virtual int GetHeight() { return height; }



  virtual void SetSize(int w, int h)
  {
   width = w;
   height = h;
  }


  virtual void SetVisible(bool v)
  {
   visible = v;
   VisibleChanged(this, v);
  }


  virtual bool IsVisible() { return visible; };


  virtual bool IsSelectable()
  {
   return ( state != STATE_DISABLED
     && state != STATE_CLICKED
     && selectable);
  }


  virtual bool IsClickable()
  {
   return ( state != STATE_DISABLED
     && state != STATE_CLICKED
     && state != STATE_HELD
     && clickable);
  }


  virtual bool IsHoldable() { return (state != STATE_DISABLED) && holdable; }


  virtual void SetSelectable(bool s) { selectable = s; }


  virtual void SetClickable(bool c) { clickable = c; }


  virtual void SetHoldable(bool d) { holdable = d; }



  virtual void SetState(int s, int c = -1);


  virtual int GetState() { return state; };


  virtual int GetStateChan() { return stateChan; };

  virtual void ResetState()
  {
   if(state != STATE_DISABLED)
    SetState(STATE_DEFAULT, -1);
  }


  virtual void SetAlpha(int a) { alpha = a; }



  virtual int GetAlpha()
  {
   int a;

   if(alphaDyn >= 0)
    a = alphaDyn;
   else
    a = alpha;

   if(parentElement)
    a *= parentElement->GetAlpha()/255.0f;

   return a;
  }


  virtual void SetScale(float s)
  {
   scaleX = s;
   scaleY = s;
  }


  virtual void SetScaleX(float s) { scaleX = s; }


  virtual void SetScaleY(float s) { scaleY = s; }


  virtual float GetScale()
  {
   float s = (scaleX+scaleY)/2 * scaleDyn;

   if(parentElement)
    s *= parentElement->GetScale();

   return s;
  }


  virtual float GetScaleX()
  {
   float s = scaleX * scaleDyn;

   if(parentElement)
    s *= parentElement->GetScaleX();

   return s;
  }


  virtual float GetScaleY()
  {
   float s = scaleY * scaleDyn;

   if(parentElement)
    s *= parentElement->GetScaleY();

   return s;
  }


  virtual bool Rumble() { return rumble; }


  virtual void SetRumble(bool r) { rumble = r; }




  virtual void SetEffect(int e, int a, int t=0);




  virtual void SetEffectOnOver(int e, int a, int t=0);

  virtual void SetEffectGrow() { SetEffectOnOver(EFFECT_SCALE, 4, 110); }

  virtual void ResetEffects();


  virtual int GetEffect() const { return effects; }

  virtual bool IsAnimated() const { return (GetEffect() > 0); }

  virtual void SetBounds(iRect r) { cutBoundsRect = r; }




  virtual bool IsInside(int x, int y)
  {
   return ( x > this->GetLeft()
     && x < (this->GetLeft()+width)
     && y > this->GetTop()
     && y < (this->GetTop()+height));
  }



  virtual void SetPosition(int x, int y)
  {
   xoffset = x;
   yoffset = y;
  }




  virtual void SetPosition(int x, int y, int z)
  {
   xoffset = x;
   yoffset = y;
   zoffset = z;
  }


  virtual int GetSelected() { return -1; }



  virtual void SetAlignment(int a) { alignment = a; }

  virtual int GetAlignment() const { return alignment; }


  virtual void Update(GuiTrigger * t __attribute__((unused))) { }

  virtual void Draw() { }


  virtual void UpdateEffects();

  POINT PtrToScreen(POINT p)
  {
   POINT r = { p.x + GetLeft(), p.y + GetTop() };
   return r;
  }

  POINT PtrToControl(POINT p)
  {
   POINT r = { p.x - GetLeft(), p.y - GetTop() };
   return r;
  }

  sigslot::signal2<GuiElement *, bool> VisibleChanged;
  sigslot::signal3<GuiElement *, int, int> StateChanged;
 protected:
  bool rumble;
  bool visible;
  bool selectable;
  bool clickable;
  bool holdable;
  int width;
  int height;
  int xoffset;
  int yoffset;
  int zoffset;
  int alpha;
  f32 scaleX;
  f32 scaleY;
  int alignment;
  int state;
  int stateChan;
  iRect cutBoundsRect;
  GuiElement * parentElement;


  int xoffsetDyn;
  int yoffsetDyn;
  int alphaDyn;
  f32 scaleDyn;
  int changervar;
  int effects;
  int effectAmount;
  int effectTarget;
  int effectsOver;
  int effectAmountOver;
  int effectTargetOver;
};
# 18 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_image.h" 1
# 21 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_image.h"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_imagedata.h" 1
# 21 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_imagedata.h"
# 1 "d:/devkitPro/libogc/include/gd.h" 1

extern "C" {
# 888 "d:/devkitPro/libogc/include/gd.h"
}
# 22 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_imagedata.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../ImageOperations/GifImage.hpp" 1
# 31 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../ImageOperations/GifImage.hpp"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../ImageOperations/../Tools/timer.h" 1
# 30 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../ImageOperations/../Tools/timer.h"
extern "C" {



# 1 "d:/devkitPro/libogc/include/ogc/lwp_watchdog.h" 1




# 1 "d:/devkitPro/libogc/include/ogc/lwp_queue.h" 1
# 6 "d:/devkitPro/libogc/include/ogc/lwp_watchdog.h" 2
# 62 "d:/devkitPro/libogc/include/ogc/lwp_watchdog.h"
extern "C" {


extern vu32 _wd_sync_level;
extern vu32 _wd_sync_count;
extern u32 _wd_ticks_since_boot;

extern lwp_queue _wd_ticks_queue;

extern u32 gettick();
extern u64 gettime();
extern void settime(u64);

u32 diff_sec(u64 start,u64 end);
u32 diff_msec(u64 start,u64 end);
u32 diff_usec(u64 start,u64 end);
u32 diff_nsec(u64 start,u64 end);

typedef void (*wd_service_routine)(void *);

typedef struct _wdcntrl {
 lwp_node node;
 u64 start;
 u32 id;
 u32 state;
 u64 fire;
 wd_service_routine routine;
 void *usr_data;
} wd_cntrl;

void __lwp_watchdog_init();
void __lwp_watchdog_settimer(wd_cntrl *wd);
void __lwp_wd_insert(lwp_queue *header,wd_cntrl *wd);
u32 __lwp_wd_remove(lwp_queue *header,wd_cntrl *wd);
void __lwp_wd_tickle(lwp_queue *queue);
void __lwp_wd_adjust(lwp_queue *queue,u32 dir,s64 interval);






 }
# 35 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../ImageOperations/../Tools/timer.h" 2

typedef struct _TimeStruct
{
 u32 tm_sec;
 u32 tm_min;
 u32 tm_hour;
 u32 tm_mday;
 u32 tm_mon;
 u32 tm_year;
} TimeStruct;

bool TimePassed(int limit);
void ConvertDosDate(u64 ulDosDate, TimeStruct * ptm);
void ConvertNTFSDate(u64 ulNTFSDate, TimeStruct * ptm);



}

class Timer
{
 public:
  Timer() { starttick = gettime(); };
  ~Timer() { };
  float elapsed() const { return (float) (gettime()-starttick)/(1000.0f*(243000000u/4000)); };
  u32 elapsedMilliSecs() const { return (u32) ((gettime()-starttick)/(243000000u/4000)); };
  void reset() { starttick = gettime(); };
 protected:
  u64 starttick;
};
# 32 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../ImageOperations/GifImage.hpp" 2

typedef struct
{
 u8 * image;
 int width;
 int height;
 int offsetx;
 int offsety;
 int Delay;
 int Disposal;
 bool Transparent;
} GifFrame;

class GifImage
{
 public:
  GifImage(const u8 * img, int imgSize);
  virtual ~GifImage();
  void LoadImage(const u8 * img, int imgSize);
  u8 * GetFrameImage(int pos);
  int GetWidth() { return MainWidth; };
  int GetHeight() { return MainHeight; };
  int GetFrameCount() { return Frames.size(); };
  void Draw(int x, int y, int z, int degrees, float scaleX,
      float scaleY, int alpha, int minwidth, int maxwidth,
      int minheight, int maxheight);
 protected:
  int MainWidth;
  int MainHeight;
  int last;
  int currentFrame;
  float lastTimer;
  Timer DelayTimer;
  std::vector<GifFrame> RedrawQueue;
  std::vector<GifFrame> Frames;
};
# 23 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_imagedata.h" 2

class GuiImageData
{
 public:

  GuiImageData();


  GuiImageData(const u8 * img, int imgSize);

  GuiImageData(const char * filepath);

  virtual ~GuiImageData();



  void LoadImage(const u8 * img, int imgSize);


  u8 * GetImage() { return data ? data : AnimGif ? AnimGif->GetFrameImage(0) : __null; };


  int GetWidth() { return width; };


  int GetHeight() { return height; };

  u8 GetTextureFormat() { return format; };

  GifImage * GetAnimGif() { return AnimGif; };
 protected:
  void LoadTPL(const u8 *img, int imgSize);

  u8 * data;
  int height;
  int width;
  u8 format;
  GifImage * AnimGif;
};
# 22 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_image.h" 2

enum
{
 IMAGE_TEXTURE,
 IMAGE_COLOR,
 IMAGE_MULTICOLOR,
 IMAGE_DATA
};


class GuiImage : public GuiElement
{
 public:

  GuiImage();


  GuiImage(GuiImageData * img);





  GuiImage(u8 * img, int w, int h);





  GuiImage(int w, int h, GXColor c);





  GuiImage(int w, int h, GXColor * c);

  virtual ~GuiImage();

  float GetAngle();


  void SetAngle(float a);


  void SetTileHorizontal(int t);


  void SetTileVertical(int t);

  void Draw();


  u8 * GetImage();


  void SetImage(GuiImageData * img);





  void SetImage(u8 * img, int w, int h, int f = 0x6);



  GXColor GetPixel(int x, int y);




  void SetPixel(int x, int y, GXColor color);

  void SetGrayscale(void);



  void ColorStripe(int s);



  void SetStripe(int s);

  void SetImageColor(GXColor * c, int colorCount = 1);

  void SetSize(int w, int h);

  GXColor * GetColorPtr() { return (GXColor *) &color; }

  void SetFormat(u8 f) { format = f; }
 protected:
  int imgType;
  u8 * image;
  f32 imageangle;
  int tileHorizontal;
  int tileVertical;
  int stripe;
  u8 format;
  GXColor color[5];
  GifImage * AnimGif;
};
# 19 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_button.h" 1
# 21 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_button.h"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_tooltip.h" 1
# 20 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_tooltip.h"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_element.h" 1
# 21 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_tooltip.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_text.h" 1
# 26 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_text.h"
class FreeTypeGX;


class GuiText : public GuiElement
{
 public:




  GuiText(const char * t, int s, GXColor c);




  GuiText(const wchar_t * t, int s, GXColor c);



  GuiText(const char * t);

  virtual ~GuiText();


  virtual void SetText(const char * t);
  virtual void SetText(std::string t) { SetText(t.c_str()); }
  virtual void SetText(const wchar_t * t);
  virtual void SetText(std::wstring t) { SetText(t.c_str()); }
  virtual void SetTextf(const char *format, ...) __attribute__((format(printf,2,3)));







  static void SetPresets(int sz, GXColor c, int w, int a);


  void SetFontSize(int s);




  void SetMaxWidth(int w = 0, int m = WRAP);


  void SetColor(GXColor c);

  virtual const wchar_t * GetText() const { return text; }
  virtual std::string toUTF8(void) const;

  int GetTextWidth();
  int GetTextWidth(int ind);

  int GetTextMaxWidth() { return maxWidth; }

  virtual int GetLinesCount() { return 1; };

  void SetPassChar(wchar_t p) { passChar = p; }

  int GetFontSize() { return size; };

  void SetLinesToDraw(int l) { linestodraw = l; }

  const wchar_t * GetDynText(int ind = 0);
  virtual const wchar_t * GetTextLine(int ind) { return GetDynText(ind); };



  bool SetFont(const u8 *font, const u32 filesize);

  void Draw();
 protected:

  void ClearDynamicText();

  void MakeDottedText();

  void ScrollText();

  void WrapText();

  wchar_t *text;
  std::vector<wchar_t *> textDyn;
  int wrapMode;
  int textScrollPos;
  int textScrollInitialDelay;
  int textScrollDelay;
  int size;
  int maxWidth;
  GXColor color;
  FreeTypeGX *font;
  int textWidth;
  int currentSize;
  int linestodraw;
  wchar_t passChar;
};
# 22 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_tooltip.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_image.h" 1
# 23 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_tooltip.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_imagedata.h" 1
# 24 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_tooltip.h" 2

class GuiTooltip : public GuiElement
{
 public:

  GuiTooltip(const char *t);
  GuiTooltip(const wchar_t *t);
  GuiTooltip(std::string t);
  GuiTooltip(std::wstring t);
  void InternalInit();

  virtual ~GuiTooltip();

  void SetText(const char * t);
  void SetText(const wchar_t * t);
  void SetText(std::string t) { SetText(t.c_str()); }
  void SetText(std::wstring t) { SetText(t.c_str()); }

  void SetFontSize(int size);

  void SetColor(GXColor c);

  void SetElapseTime(float t);

  float GetElapseTime() { return ElapseTime; };

  void Draw();
 protected:
  float ElapseTime;
  int FontSize;
  GXColor color;
  GuiImage * leftImage;
  GuiImage * tileImage;
  GuiImage * rightImage;
  GuiImageData * tooltipLeft;
  GuiImageData * tooltipTile;
  GuiImageData * tooltipRight;
  GuiText * text;
};
# 22 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_button.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_trigger.h" 1
# 22 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_trigger.h"
enum
{
 TRIGGER_SIMPLE,
 TRIGGER_HELD,
 TRIGGER_BUTTON_ONLY,
 TRIGGER_BUTTON_ONLY_HELD
};

typedef struct _paddata {
 u16 btns_d;
 u16 btns_u;
 u16 btns_h;
 s8 stickX;
 s8 stickY;
 s8 substickX;
 s8 substickY;
 u8 triggerL;
 u8 triggerR;
} PADData;


class GuiTrigger
{
 public:

  GuiTrigger();

  virtual ~GuiTrigger();




  void SetSimpleTrigger(s32 ch, u32 wiibtns, u16 gcbtns);




  void SetHeldTrigger(s32 ch, u32 wiibtns, u16 gcbtns);




  void SetButtonOnlyTrigger(s32 ch, u32 wiibtns, u16 gcbtns);
  void SetButtonOnlyHeldTrigger(s32 ch, u32 wiibtns, u16 gcbtns);




  s8 WPAD_Stick(u8 right, int axis);


  bool Left();


  bool Right();


  bool Up();


  bool Down();

  u8 type;
  s32 chan;
  WPADData * wpad;
  WPADData wpaddata;
  PADData pad;
};

class SimpleGuiTrigger : public GuiTrigger
{
 public:
  SimpleGuiTrigger(s32 ch, u32 wiibtns, u16 gcbtns)
  {
   SetSimpleTrigger(ch, wiibtns, gcbtns);
  }
};
# 23 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_button.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_sound.h" 1
# 23 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_sound.h"
class GuiSound
{
 public:



  GuiSound(const char * filepath);
  GuiSound(const u8 * sound, int filesize, bool allocated = false, int voice = -1);

  virtual ~GuiSound();

  bool Load(const char * filepath);

  bool Load(const u8 * sound, int filesize, bool allocated = true);

  bool LoadSoundEffect(const u8 * snd, s32 len);

  void Play();

  void Stop();

  void Pause();

  void Resume();


  bool IsPlaying();

  void Rewind();


  void SetVolume(int v);

  void SetLoop(u8 l);

  void UncompressSoundbin(const u8 * snd, int len, bool isallocated);
 protected:

  void FreeMemory();
  u8 * sound;
  int length;
  s32 voice;
  int volume;
  u8 loop;
  u32 SoundEffectLength;
  bool allocated;
};
# 24 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_button.h" 2


class GuiButton : public GuiElement
{
 public:



  GuiButton(int w, int h);

  virtual ~GuiButton();


  void SetImage(GuiImage* i);


  void SetImageOver(GuiImage* i);


  void SetImageHold(GuiImage* i);


  void SetImageClick(GuiImage* i);


  void SetIcon(GuiImage* i);


  void SetIconOver(GuiImage* i);


  void SetIconHold(GuiImage* i);


  void SetIconClick(GuiImage* i);



  void SetLabel(GuiText* t, int n = 0);



  void SetLabelOver(GuiText* t, int n = 0);



  void SetLabelHold(GuiText* t, int n = 0);



  void SetLabelClick(GuiText* t, int n = 0);


  void SetSoundOver(GuiSound * s);


  void SetSoundHold(GuiSound * s);


  void SetSoundClick(GuiSound * s);

  void SetTooltip(GuiTooltip * t);
  void ResetTooltipTimer() { SelectTimer.reset(); }

  void SetBounds(iRect w);


  void SetTrigger(GuiTrigger * t);



  void SetTrigger(u8 i, GuiTrigger * t);

  void Draw();


  void Update(GuiTrigger * t);
  sigslot::signal3<GuiButton *, int, const POINT &> Clicked;
  sigslot::signal3<GuiButton *, int, const POINT &> Held;
  sigslot::signal3<GuiButton *, int, const POINT &> Released;
 protected:

  void Init();
  bool ClickAndHold;

  GuiImage * image;
  GuiImage * imageOver;
  GuiImage * imageHold;
  GuiImage * imageClick;
  GuiImage * icon;
  GuiImage * iconOver;
  GuiImage * iconHold;
  GuiImage * iconClick;
  GuiText * label[3];
  GuiText * labelOver[3];
  GuiText * labelHold[3];
  GuiText * labelClick[3];
  GuiSound * soundOver;
  GuiSound * soundHold;
  GuiSound * soundClick;
  GuiTooltip * tooltip;
  Timer SelectTimer;
  GuiTrigger * trigger[6];
};
# 20 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_text.h" 1
# 21 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/OptionList.hpp" 1
# 22 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/OptionList.hpp"
class OptionList
{
 public:
  OptionList();
  virtual ~OptionList();
  void SetName(int i, const char *format, ...) __attribute__((format (printf, 3, 4)));
  void SetValue(int i, const char *format, ...) __attribute__((format (printf, 3, 4)));
  const char * GetName(int i);
  const char * GetValue(int i);
  void Resize(int size);
  int GetLength() { return name.size(); }
  bool IsChanged() { bool ret = listChanged; listChanged = false; return ret;}
  void RemoveOption(int i);
  void ClearList();
 private:
  std::vector<char *> name;
  std::vector<char *> value;
  bool listChanged;
};
# 22 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/Scrollbar.hpp" 1
# 27 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/Scrollbar.hpp"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/../GUI/gui_element.h" 1
# 28 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/Scrollbar.hpp" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/../GUI/gui_button.h" 1
# 29 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/Scrollbar.hpp" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/../GUI/PictureButton.h" 1
# 20 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/../GUI/PictureButton.h"
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/../GUI/gui_button.h" 1
# 21 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/../GUI/PictureButton.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/../GUI/gui_image.h" 1
# 22 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/../GUI/PictureButton.h" 2

class PictureButton : public GuiButton
{
 public:
  PictureButton(const char *img = __null, const char *imgOver = __null, GuiSound * sndClick = __null, GuiSound * sndOver = __null);

  PictureButton(GuiImageData *img);
  PictureButton(GuiImageData *img, GuiImageData *imgOver);
  PictureButton(GuiImageData *img, GuiImageData *imgOver, GuiSound * sndClick);
  PictureButton(GuiImageData *img, GuiImageData *imgOver, GuiSound * sndClick, GuiSound * sndOver);

  virtual ~PictureButton();
 private:
  void Init(const char *img, const char *imgOver, GuiSound * sndClick, GuiSound * sndOver);
  void Init(GuiImageData *img, GuiImageData *imgOver, GuiSound * sndClick, GuiSound * sndOver);
  GuiImageData *imgData;
  GuiImageData *imgOverData;
};
# 30 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Controls/Scrollbar.hpp" 2

class Scrollbar : public GuiElement, public sigslot::has_slots<>
{
 public:
  Scrollbar(int height, u8 mode = LISTMODE);
  virtual ~Scrollbar();

  void SetDPadControl(bool a) { AllowDPad = a; }
  void SetButtonScroll(u32 wiibtns, u16 gcbtns) { ButtonScroll = wiibtns; ButtonScrollGC = gcbtns; }
  void ScrollOneUp();
  void ScrollOneDown();
  int GetSelectedItem() { return SelItem; }
  int GetSelectedIndex() { return SelInd; }
  void SetScrollSpeed(u16 speed) { ScrollSpeed = speed; }
  void SetButtonScrollSpeed(u16 speed) { ButtonScrollSpeed = speed; }
  void SetBounds(iRect w);
  void Draw();
  void Update(GuiTrigger * t);

  enum
  {
   ICONMODE = 0,
   LISTMODE,
   CUSTOMMODE
  };

  void SetPageSize(int size);
  void SetRowSize(int size);
  void SetSelectedItem(int pos);
  void SetSelectedIndex(int pos);
  void SetSelected(int selItem, int selIndex);
  void SetEntrieCount(int cnt);

  sigslot::signal2<int, int> listChanged;

 protected:
  void setScrollboxPosition(int SelItem, int SelInd);
  void CheckDPadControls(GuiTrigger *t);
  void ScrollByButton(GuiTrigger *t);

  void OnUpButtonHold(GuiButton *sender, int pointer, const POINT &p);
  void OnDownButtonHold(GuiButton *sender, int pointer, const POINT &p);
  void OnBoxButtonHold(GuiButton *sender, int pointer, const POINT &p);

  u8 Mode;
  u32 ScrollState;
  u16 ScrollSpeed;
  u16 ButtonScrollSpeed;
  u32 ButtonScroll;
  u16 ButtonScrollGC;
  bool AllowDPad;

  int MinHeight;
  int MaxHeight;
  int SelItem;
  int SelInd;
  int RowSize;
  int PageSize;
  int EntrieCount;
  int ButtonPositionX;
  int pressedChan;
  bool listchanged;

  PictureButton * arrowUpBtn;
  PictureButton * arrowDownBtn;
  PictureButton * scrollbarBoxBtn;

  GuiImage * scrollbarTopImg;
  GuiImage * scrollbarBottomImg;
  GuiImage * scrollbarTileImg;
  GuiImage * oneButtonScrollImg;

  GuiImageData * scrollbarTop;
  GuiImageData * scrollbarBottom;
  GuiImageData * scrollbarTile;
  GuiImageData * oneButtonScrollImgData;

  GuiSound * btnSoundOver;
  GuiSound * btnSoundClick;

  GuiTrigger * trigHeldA;
};
# 23 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.h" 2




class GuiOptionBrowser : public GuiElement, public sigslot::has_slots<>
{
 public:
  GuiOptionBrowser(OptionList * l);
  virtual ~GuiOptionBrowser();
  void Draw();
  void Refresh() { OnListChange(selectedItem, listOffset); }
  void Update(GuiTrigger * t);


  sigslot::signal2<GuiOptionBrowser *, int> Clicked;
 protected:
  void OnButtonClick(GuiButton *sender, int pointer, const POINT &p);
  void OnListChange(int selItem, int selIndex);
  void SetCol2Position(int x);
  int selectedItem;
  int listOffset;
  int coL2;
  bool listChanged;

  OptionList *options;
  GuiButton * optionBtn[9];
  GuiText * optionTxt[9];
  GuiImage * optionBg[9];
  GuiText * optionVal[9];

  Scrollbar * scrollbar;

  GuiImage * bgOptionsImg;

  GuiImageData * bgOptions;
  GuiImageData * bgOptionsEntry;

  GuiSound * btnSoundClick;
  GuiTrigger * trigA;
};
# 18 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.cpp" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Themes/CTheme.h" 1







# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Themes/Resources.h" 1
# 32 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Themes/Resources.h"
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/map" 1 3
# 58 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/map" 3
       
# 59 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/map" 3


# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 1 3
# 64 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 86 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 172 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 213 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 229 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 252 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 298 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 417 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 444 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
# 481 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 516 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
# 565 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      iterator



      insert(iterator __position, const value_type& __x)

      { return _M_t._M_insert_unique_(__position, __x); }
# 591 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 631 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 647 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 681 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 697 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 740 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 755 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 767 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 782 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 797 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 836 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 855 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 880 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 897 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 62 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/map" 2 3
# 1 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 1 3
# 63 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 85 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 170 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 210 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 226 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 249 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 295 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 412 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 439 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 472 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      iterator



      insert(iterator __position, const value_type& __x)

      { return _M_t._M_insert_equal_(__position, __x); }
# 499 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 552 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 568 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 606 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 622 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 665 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 680 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 704 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 719 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 756 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 773 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 798 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 815 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 63 "d:\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/map" 2 3
# 33 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Themes/Resources.h" 2

# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_sound.h" 1
# 35 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Themes/Resources.h" 2

class Resources
{
 public:
  static Resources *Instance();
  static void DestroyInstance();

  static bool LoadFiles(const char * path);

  static const u8 *GetFile(const char *filename);
  static u32 GetFileSize(const char *filename);

  static GuiImageData *GetImageData(const char *filename);
  static GuiImage *GetImage(const char *filename);
  static GuiSound *GetSound(const char *filename);

  static void Remove(GuiImageData *img);
  static void Remove(GuiSound *snd);
 private:
  GuiImageData *InternalGetImageData(const u8 *img, u32 imgSize);
  GuiSound *InternalGetSound(const u8 *snd, s32 sndSize);
  static void Clear();
  void InternalRemoveImageData(GuiImageData *img);
  void InternalRemoveSound(GuiSound *snd);

  ~Resources();

  static Resources *instance;

  std::map<const u8 *, GuiImageData *> images;
  std::map<const u8 *, GuiSound *> sounds;

  std::map<GuiImageData *, int> imageCount;
  std::map<GuiSound *, int> soundCount;
};
# 9 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Themes/CTheme.h" 2
# 1 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Themes/gettheme.h" 1




extern "C" {


# 1 "d:/devkitPro/libogc/include/ogc/gx.h" 1
# 9 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Themes/gettheme.h" 2


int getThemeInt(const char *msgid);
float getThemeFloat(const char *msgid);
int getThemeAlignment(const char *msgid);
GXColor getThemeColor(const char *msgid);
bool LoadTheme(const char* themeFile);
void ThemeCleanUp(void);







}
# 10 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/../Themes/CTheme.h" 2

class Theme
{
 public:

  static void SetDefault();

  static bool Load(const char * path);

  static bool LoadFont(const char *path);

  static bool loadSystemFont(bool korean);

  static void Reload(bool defaultTheme, short returnToMenu);

  static void CleanUp();


  static bool ShowTooltips;
 private:

  static void ClearFontData();
};
# 19 "d:/Projects/SaveGameManager/savegame-manager-gx/trunk/source/GUI/gui_optionbrowser.cpp" 2




GuiOptionBrowser::GuiOptionBrowser(OptionList * l)
{
 options = l;
 coL2 = 50;
 selectable = true;
 listOffset = 0;
 listChanged = true;
 selectedItem = 0;

 trigA = new GuiTrigger();
 trigA->SetSimpleTrigger(-1, Settings.Controls.WiiControls.ClickButton | Settings.Controls.ClassicControls.ClickButton << 16, Settings.Controls.GCControls.ClickButton);

 btnSoundClick = Resources::GetSound("button_click.wav");
 btnSoundClick->SetVolume(Settings.SFXVolume);

 bgOptions = Resources::GetImageData("browser_options.png");
 bgOptionsImg = new GuiImage(bgOptions);
 bgOptionsImg->SetParent(this);
 bgOptionsImg->SetAlignment(ALIGN_LEFT | ALIGN_MIDDLE);

 width = bgOptionsImg->GetWidth();
 height = bgOptionsImg->GetHeight();

 bgOptionsEntry = Resources::GetImageData("browser_bg_selection.png");

 scrollbar = new Scrollbar(bgOptionsImg->GetHeight()+20);
 scrollbar->SetParent(this);
 scrollbar->SetAlignment(ALIGN_RIGHT | ALIGN_TOP);
 scrollbar->SetPosition(6, -10);
 scrollbar->SetScrollSpeed(Settings.ScrollSpeed);
 scrollbar->listChanged.connect(this, &GuiOptionBrowser::OnListChange);
 scrollbar->SetButtonScroll(Settings.Controls.WiiControls.OneButtonScroll | Settings.Controls.ClassicControls.OneButtonScroll << 16, Settings.Controls.GCControls.OneButtonScroll);

 for(int i = 0; i < 9; i++)
 {
  optionTxt[i] = new GuiText((char*) __null, 20, getThemeColor("r=0 g=0 b=0 a=255 - option browser entry text color"));
  optionTxt[i]->SetAlignment(ALIGN_LEFT | ALIGN_MIDDLE);
  optionTxt[i]->SetPosition(15,0);

  optionVal[i] = new GuiText((char*) __null, 20, getThemeColor("r=0 g=0 b=0 a=255 - option browser entry text color"));
  optionVal[i]->SetAlignment(ALIGN_LEFT | ALIGN_MIDDLE);
  optionVal[i]->SetPosition(250,0);
  optionVal[i]->SetMaxWidth(width-optionTxt[i]->GetLeft()-50,DOTTED);

  optionBg[i] = new GuiImage(bgOptionsEntry);

  optionBtn[i] = new GuiButton(width-(8+scrollbar->GetWidth()-6),29);
  optionBtn[i]->SetParent(this);
  optionBtn[i]->SetState(STATE_DISABLED);
  optionBtn[i]->SetLabel(optionTxt[i], 0);
  optionBtn[i]->SetLabel(optionVal[i], 1);
  optionBtn[i]->SetImageOver(optionBg[i]);
  optionBtn[i]->SetPosition(8,29*i+9);
  optionBtn[i]->SetTrigger(trigA);
  optionBtn[i]->SetSoundClick(btnSoundClick);
  optionBtn[i]->Clicked.connect(this, &GuiOptionBrowser::OnButtonClick);
 }
}




GuiOptionBrowser::~GuiOptionBrowser()
{
 delete scrollbar;

 delete bgOptionsImg;

 Resources::Remove(bgOptions);
 Resources::Remove(bgOptionsEntry);
 Resources::Remove(btnSoundClick);

 delete trigA;

 for(int i = 0; i < 9; i++)
 {
  delete optionTxt[i];
  delete optionVal[i];
  delete optionBg[i];
  delete optionBtn[i];
 }
}

void GuiOptionBrowser::SetCol2Position(int x)
{
 for(int i = 0; i < 9; i++)
  optionVal[i]->SetPosition(x,0);
}

void GuiOptionBrowser::OnButtonClick(GuiButton *sender, int pointer __attribute__((unused)), const POINT &p __attribute__((unused)))
{
 for(int i = 0; i < 9; i++)
 {
  if(sender == optionBtn[i])
  {
   Clicked(this, listOffset+i);
   break;
  }
 }
}




void GuiOptionBrowser::Draw()
{
 if(!this->IsVisible())
  return;

 bgOptionsImg->Draw();

 for(int i = 0; i < 9 && listOffset+i < options->GetLength(); i++)
 {
  optionBtn[i]->Draw();
 }

 scrollbar->Draw();

 this->UpdateEffects();
}

void GuiOptionBrowser::OnListChange(int selItem, int selIndex)
{
 selectedItem = selItem;
 listOffset = selIndex;
 int maxNameWidth = 0;

 for(int i = 0; i < 9; i++)
 {
  if(listOffset+i < options->GetLength())
  {
   if(optionBtn[i]->GetState() == STATE_DISABLED)
   {
    optionBtn[i]->SetVisible(true);
    optionBtn[i]->SetState(STATE_DEFAULT);
   }

   optionTxt[i]->SetText(options->GetName(listOffset+i));
   optionVal[i]->SetText(options->GetValue(listOffset+i));

   if(maxNameWidth < optionTxt[i]->GetTextWidth())
    maxNameWidth = optionTxt[i]->GetTextWidth();

   if(coL2 < (24+maxNameWidth+16))
    coL2 = 24+maxNameWidth+16;
  }
  else
  {
   optionBtn[i]->SetVisible(false);
   optionBtn[i]->SetState(STATE_DISABLED);
  }
 }

 for(int i = 0; i < 9; i++)
 {
  optionVal[i]->SetPosition(coL2,0);
  optionVal[i]->SetMaxWidth(width-coL2-50, DOTTED);
 }
}

void GuiOptionBrowser::Update(GuiTrigger * t)
{
 if(state == STATE_DISABLED || !t)
  return;

 scrollbar->Update(t);

 if(options->IsChanged())
  OnListChange(selectedItem, listOffset);

 for(int i=0; i<9; i++)
 {
  if(i != selectedItem && optionBtn[i]->GetState() == STATE_SELECTED)
  {
   optionBtn[i]->ResetState();
   optionVal[i]->SetMaxWidth(width-coL2-50, DOTTED);
  }
  else if(i == selectedItem && optionBtn[i]->GetState() == STATE_DEFAULT)
  {
   optionBtn[selectedItem]->SetState(STATE_SELECTED, t->chan);
   optionVal[selectedItem]->SetMaxWidth(width-coL2-60, SCROLL_HORIZONTAL);
  }

  int currChan = t->chan;

  if(t->wpad->ir.valid && !optionBtn[i]->IsInside(t->wpad->ir.x, t->wpad->ir.y))
   t->chan = -1;

  optionBtn[i]->Update(t);
  t->chan = currChan;

  if(i != selectedItem && optionBtn[i]->GetState() == STATE_SELECTED)
  {
   selectedItem = i;
   optionVal[selectedItem]->SetMaxWidth(width-coL2-60, SCROLL_HORIZONTAL);
  }
 }

 scrollbar->SetEntrieCount(options->GetLength());
 scrollbar->SetPageSize(9);
 scrollbar->SetRowSize(0);
 scrollbar->SetSelectedItem(selectedItem);
 scrollbar->SetSelectedIndex(listOffset);
}
